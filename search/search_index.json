{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sqript est un langage de scripting d\u00e9di\u00e9 au jeu Minecraft et \u00e0 l'API Forge . Il permet, entre autres, de rajouter des fonctionnalit\u00e9s en jeu, ou d'en modifier, gr\u00e2ce \u00e0 des scripts . Apprendre Sqript La structure d'un script Les \u00e9v\u00e8nements Les variables Les actions et les expressions Les conditions Les collections Les boucles Les fonctions Les options Liste des \u00e9v\u00e8nements, actions, expressions et blocs impl\u00e9ment\u00e9s Ajouter des fonctionnalit\u00e9s \u00e0 Sqript N\u00e9cessite de bonnes connaissances de Java et des expressions r\u00e9guli\u00e8res . Les conventions Le ScriptContext Le ScriptClock Les patterns Ajouter un type Ajouter un \u00e9v\u00e8nement Ajouter une expression Ajouter une action Ajouter un bloc","title":"Pr\u00e9sentation"},{"location":"#apprendre-sqript","text":"La structure d'un script Les \u00e9v\u00e8nements Les variables Les actions et les expressions Les conditions Les collections Les boucles Les fonctions Les options Liste des \u00e9v\u00e8nements, actions, expressions et blocs impl\u00e9ment\u00e9s","title":"Apprendre Sqript"},{"location":"#ajouter-des-fonctionnalites-a-sqript","text":"N\u00e9cessite de bonnes connaissances de Java et des expressions r\u00e9guli\u00e8res . Les conventions Le ScriptContext Le ScriptClock Les patterns Ajouter un type Ajouter un \u00e9v\u00e8nement Ajouter une expression Ajouter une action Ajouter un bloc","title":"Ajouter des fonctionnalit\u00e9s \u00e0 Sqript"},{"location":"base/Actions/","text":"Une action est une ligne de script r\u00e9alisant une ou plusieurs modification, au jeu ou au contexte d'ex\u00e9cution. Pour pouvoir param\u00e9trer le fonctionnement d'une action, celles-si s'appuient sur des expressions . Cependant, une action peut fonctionner sans expression, tout comme une expression peut \u00eatre utilis\u00e9e en dehors d'une action, comme pour d\u00e9finir une variable, v\u00e9rifier une condition, etc. La principale diff\u00e9rence entre les actions et les expressions r\u00e9side dans le fait que les actions ne retournent aucun r\u00e9sultat, l\u00e0 o\u00f9 les expressions retournent forc\u00e9ment un r\u00e9sultat. Ce r\u00e9sultat peut \u00eatre de n'importe quel type. Tous les types primitifs peuvent \u00eatre utilis\u00e9s en tant que param\u00e8tre d'une expression ou d'une action. Par exemple, cos(5) reconna\u00eet le nombre 5 et lui applique la fonction cosinus. Autre exemple, l'expression numbers in range of {number} retourne un tableau contenant tous les nombres allant de 0 \u00e0 {number} . Cependant, l'action shuffle {array} ne fait que m\u00e9langer al\u00e9atoirement un tableau, et ne retourne aucun r\u00e9sultat. Elle applique directement la modification sur la variable pass\u00e9e en param\u00e8tre. Certaines expressions peuvent demander plusieurs param\u00e8tres pour pouvoir s'ex\u00e9cuter. Par exemple, l'expression {element} is in {array} fonctionne avec n'importe quel \u00e9l\u00e9ment en premier param\u00e8tre, et avec un tableau en second param\u00e8tre. Warning Les expressions sont reconnues en fonction de leur \"position\" dans la ligne, les expressions les plus \u00e0 droites ayant la priorit\u00e9. Cela permet une interpr\u00e9tation coh\u00e9rente de la ligne, comme le ferait un lecteur humain. Tip Pour \u00e9viter les confusions, il est possible d'utiliser des parenth\u00e8ses pour d\u00e9finir l'ordre dans lequel les expressions doivent s'appliquer aux donn\u00e9es. Par exemple, l'expression \u2460 random element of numbers in range of (50+20) + 10 sera sensiblement diff\u00e9rente de l'expression \u2461 random element of numbers in range of (50) + 20 + 10 . Dans \u2460, le r\u00e9sultat sera la somme d'un \u00e9l\u00e9ment al\u00e9atoire du tableau contenant les nombres entiers jusqu'\u00e0 70, et de 10. L'expression \u2460 retournera donc un nombre compris entre 10 et 80. Cependant, l'expression \u2461 retournera la somme d'un \u00e9l\u00e9ment al\u00e9atoire du tableau contenant les nombres entiers jusqu'\u00e0 50, et de 10 et de 20. L'expression \u2461 retournera donc un nombre compris entre 30 et 80. Cela peut para\u00eetre \u00e9vident, mais dans des expressions plus complexes l'usage des parenth\u00e8ses est important, d'une part pour \u00e9viter des probl\u00e8mes li\u00e9s aux types des param\u00e8tres de l'expression, et d'autre part pour permettre une meilleure lecture du script.","title":"Les actions et les expressions"},{"location":"base/Boucles/","text":"Nous verrons ici les boucles qui permettent de r\u00e9p\u00e9ter une partie du code un certain nombres de fois. While Cette boucle ex\u00e9cutera le bloc qui lui est associ\u00e9 tant que la condition qui lui est donn\u00e9e est v\u00e9rifi\u00e9e. Sa syntaxe d'utilisation est while <condition>: . Par exemple le script suivant affichera successivement dans la console les nombres de 0 \u00e0 50. on script load : set counter to 0 while counter < 50 : print \"counter = \" + counter add 1 to counter Warning Attention aux boucles infinies. Le code while True: ou while 5=5: ex\u00e9cutera le code une infinit\u00e9 de fois, ce qui stoppera l'ex\u00e9cution du jeu tant que la boucle ne sera pas termin\u00e9e. For Cette boucle est un peu diff\u00e9rente des deux pr\u00e9c\u00e9dentes. En effet, elle ne s'appuie par sur une condition pour fonctionner mais sur un tableau. Si l'expression pass\u00e9e dans la boucle n'est pas un tableau, une erreur sera lev\u00e9e. Sa syntaxe d'utilisation est for {variable} in {array} . Le bloc associ\u00e9 \u00e0 la boucle va \u00eatre ex\u00e9cut\u00e9 pour chaque \u00e9l\u00e9ment du tableau, qui peut \u00eatre r\u00e9cup\u00e9r\u00e9 gr\u00e2ce \u00e0 la variable {variable} pass\u00e9e en premier param\u00e8tre. Par exemple : on script load : set a to numbers in range of 5 #Cr\u00e9\u00e9 un tableau \u00e9quivalent \u00e0 [0,1,2,3,4,5] for i in a : #Pour chaque \u00e9l\u00e9ment not\u00e9 i dans le tableau a print i * 2 #Affiche la valeur i*2. Casser une boucle Il est possible de stopper l'ex\u00e9cution d'une boucle, m\u00eame si la condition d'une boucle while est v\u00e9rifi\u00e9e ou m\u00eame si le tableau d'une boucle for n'a pas \u00e9t\u00e9 enti\u00e8rement parcouru. Pour cela, il suffit d'utiliser l'action break loop : Info Cela ne concerne que les boucles while et for . for i in numbers in range of 10 : print i if i = 4 : break loop Ce code affichera successivement les nombres de 1 \u00e0 4, puis quittera la boucle. Lorsque plusieurs boucles sont imbriqu\u00e9es, il est possible de quitter plusieurs boucles, en utilisant l'action break {number} loops . Les boucles while et for plac\u00e9es {number} fois plus haut seront \u00e9galement arr\u00eat\u00e9es.","title":"Les boucles"},{"location":"base/Boucles/#while","text":"Cette boucle ex\u00e9cutera le bloc qui lui est associ\u00e9 tant que la condition qui lui est donn\u00e9e est v\u00e9rifi\u00e9e. Sa syntaxe d'utilisation est while <condition>: . Par exemple le script suivant affichera successivement dans la console les nombres de 0 \u00e0 50. on script load : set counter to 0 while counter < 50 : print \"counter = \" + counter add 1 to counter Warning Attention aux boucles infinies. Le code while True: ou while 5=5: ex\u00e9cutera le code une infinit\u00e9 de fois, ce qui stoppera l'ex\u00e9cution du jeu tant que la boucle ne sera pas termin\u00e9e.","title":"While"},{"location":"base/Boucles/#for","text":"Cette boucle est un peu diff\u00e9rente des deux pr\u00e9c\u00e9dentes. En effet, elle ne s'appuie par sur une condition pour fonctionner mais sur un tableau. Si l'expression pass\u00e9e dans la boucle n'est pas un tableau, une erreur sera lev\u00e9e. Sa syntaxe d'utilisation est for {variable} in {array} . Le bloc associ\u00e9 \u00e0 la boucle va \u00eatre ex\u00e9cut\u00e9 pour chaque \u00e9l\u00e9ment du tableau, qui peut \u00eatre r\u00e9cup\u00e9r\u00e9 gr\u00e2ce \u00e0 la variable {variable} pass\u00e9e en premier param\u00e8tre. Par exemple : on script load : set a to numbers in range of 5 #Cr\u00e9\u00e9 un tableau \u00e9quivalent \u00e0 [0,1,2,3,4,5] for i in a : #Pour chaque \u00e9l\u00e9ment not\u00e9 i dans le tableau a print i * 2 #Affiche la valeur i*2.","title":"For"},{"location":"base/Boucles/#casser-une-boucle","text":"Il est possible de stopper l'ex\u00e9cution d'une boucle, m\u00eame si la condition d'une boucle while est v\u00e9rifi\u00e9e ou m\u00eame si le tableau d'une boucle for n'a pas \u00e9t\u00e9 enti\u00e8rement parcouru. Pour cela, il suffit d'utiliser l'action break loop : Info Cela ne concerne que les boucles while et for . for i in numbers in range of 10 : print i if i = 4 : break loop Ce code affichera successivement les nombres de 1 \u00e0 4, puis quittera la boucle. Lorsque plusieurs boucles sont imbriqu\u00e9es, il est possible de quitter plusieurs boucles, en utilisant l'action break {number} loops . Les boucles while et for plac\u00e9es {number} fois plus haut seront \u00e9galement arr\u00eat\u00e9es.","title":"Casser une boucle"},{"location":"base/Collections/","text":"Une collection est un objet qui permet de rassembler d'autres objets. Il existe pour l'instant deux types de collections qui sont directement impl\u00e9ment\u00e9s par Sqript : les tableaux et les dictionnaires . Les tableaux Un tableau est une variable qui contient d' autres variables. Les tableaux ont une taille infinie ( limit\u00e9e par la RAM ), et peuvent contenir n'importe quels types de variables. Un tableau peut tout \u00e0 fait contenir \u00e0 la fois des cha\u00eenes de caract\u00e8res, des nombres, voire d' autres tableaux . Une instance de TypeArray s'obtient facilement en notant entre crochets, s\u00e9par\u00e9s d'une virgule, les \u00e9l\u00e9ments qui composent notre tableau. Il est possible de cr\u00e9er un tableau vide en notant deux crochets vides [] . Il est ensuite possible de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment \u00e0 un indice particulier en notant la variable, suivie de deux crochets contenant une expression retournant un TypeNumber : def array to [true, \"test\", 5, sqrt(36)] print array[3] //Output : 6 print array[7-(3*2)] //Output : \"test\" Warning Les indices des tableaux commencent \u00e0 partir de 0. On peut ajouter ou retirer des \u00e9l\u00e9ments \u00e0 un tableau gr\u00e2ce aux actions add to et remove from : set tableau to [ 1 , 2 , 3 ] add 4 to tableau print tableau #Affiche [1,2,3,4] remove 2 from tableau print tableau #Affiche [1,3,4] Il est possible d'utiliser les op\u00e9rateurs + et - sur les tableaux pour d\u00e9signer l'ajout d'un \u00e9l\u00e9ment au tableau, ou la suppression d'un \u00e9l\u00e9ment du tableau, sans changer directement les \u00e9l\u00e9ments du tableau. set tableau to [ 1 , 2 , 3 ] print tableau + 4 #Affiche [1,2,3,4] print tableau #Affiche 1,2,3 - La valeur du tableau n'a pas \u00e9t\u00e9 intrins\u00e8quement chang\u00e9e Les dictionnaires Un dictionnaire est un tableau sp\u00e9cial, qui associe \u00e0 chaque cl\u00e9 une valeur . Pour d\u00e9finir un dictionnaire, on peut directement cr\u00e9er un dictionnaire vide avec dictionnary ou cr\u00e9er le dictionnaire avec des couples cl\u00e9 - valeur pr\u00e9d\u00e9finis par un tableau de tableaux, comme suit : set mon_dictionnaire_vide to dictionnary set mon_dictionnaire to dictionnary with [ [ \"cl\u00e9 1\" , 14 ] , [ \"cl\u00e9 2\" , 15 ] ] De la m\u00eame mani\u00e8re que pour les tableaux, on peut r\u00e9cup\u00e9rer une valeur en notant entre crochet la cl\u00e9 associ\u00e9e \u00e0 la valeur souhait\u00e9e directement apr\u00e8s le dictionnaire : set mon_dictionnaire to dictionnary with [ [ \"cl\u00e9 1\" , 14 ] , [ \"cl\u00e9 2\" , 15 ] ] print mon_dictionnaire [ \"cl\u00e9 2\" ] #Affiche 15 Tout comme les tableaux, il est possible d'ajouter un couple de valeurs au dictionnaire avec l'action add ou, sans modifier le dictionnaire, l'op\u00e9rateur + : set mon_dictionnaire_vide to dictionnary add [ \"cl\u00e9\" , \"valeur\" ] to mon_dictionnaire_vide print mon_dictionnaire_vide [ \"cl\u00e9\" ] #Affiche \"valeur\" Il est aussi possible de retirer un \u00e9l\u00e9ment du dictionnaire en utilisant l'action remove ou, sans modifier le dictionnaire, avec l'op\u00e9rateur - , avec la cl\u00e9 du couple que l'on veut retirer : set mon_dictionnaire to dictionnary with [ [ \"cl\u00e9 1\" , 14 ] , [ \"cl\u00e9 2\" , 15 ] ] remove \"cl\u00e9 1\" from mon_dictionnaire print mon_dictionnaire #Affiche [ [\"cl\u00e9 2\",15] ] Danger C'est bien la cl\u00e9 qui permet de supprimer un couple !","title":"Les collections"},{"location":"base/Collections/#les-tableaux","text":"Un tableau est une variable qui contient d' autres variables. Les tableaux ont une taille infinie ( limit\u00e9e par la RAM ), et peuvent contenir n'importe quels types de variables. Un tableau peut tout \u00e0 fait contenir \u00e0 la fois des cha\u00eenes de caract\u00e8res, des nombres, voire d' autres tableaux . Une instance de TypeArray s'obtient facilement en notant entre crochets, s\u00e9par\u00e9s d'une virgule, les \u00e9l\u00e9ments qui composent notre tableau. Il est possible de cr\u00e9er un tableau vide en notant deux crochets vides [] . Il est ensuite possible de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment \u00e0 un indice particulier en notant la variable, suivie de deux crochets contenant une expression retournant un TypeNumber : def array to [true, \"test\", 5, sqrt(36)] print array[3] //Output : 6 print array[7-(3*2)] //Output : \"test\" Warning Les indices des tableaux commencent \u00e0 partir de 0. On peut ajouter ou retirer des \u00e9l\u00e9ments \u00e0 un tableau gr\u00e2ce aux actions add to et remove from : set tableau to [ 1 , 2 , 3 ] add 4 to tableau print tableau #Affiche [1,2,3,4] remove 2 from tableau print tableau #Affiche [1,3,4] Il est possible d'utiliser les op\u00e9rateurs + et - sur les tableaux pour d\u00e9signer l'ajout d'un \u00e9l\u00e9ment au tableau, ou la suppression d'un \u00e9l\u00e9ment du tableau, sans changer directement les \u00e9l\u00e9ments du tableau. set tableau to [ 1 , 2 , 3 ] print tableau + 4 #Affiche [1,2,3,4] print tableau #Affiche 1,2,3 - La valeur du tableau n'a pas \u00e9t\u00e9 intrins\u00e8quement chang\u00e9e","title":"Les tableaux"},{"location":"base/Collections/#les-dictionnaires","text":"Un dictionnaire est un tableau sp\u00e9cial, qui associe \u00e0 chaque cl\u00e9 une valeur . Pour d\u00e9finir un dictionnaire, on peut directement cr\u00e9er un dictionnaire vide avec dictionnary ou cr\u00e9er le dictionnaire avec des couples cl\u00e9 - valeur pr\u00e9d\u00e9finis par un tableau de tableaux, comme suit : set mon_dictionnaire_vide to dictionnary set mon_dictionnaire to dictionnary with [ [ \"cl\u00e9 1\" , 14 ] , [ \"cl\u00e9 2\" , 15 ] ] De la m\u00eame mani\u00e8re que pour les tableaux, on peut r\u00e9cup\u00e9rer une valeur en notant entre crochet la cl\u00e9 associ\u00e9e \u00e0 la valeur souhait\u00e9e directement apr\u00e8s le dictionnaire : set mon_dictionnaire to dictionnary with [ [ \"cl\u00e9 1\" , 14 ] , [ \"cl\u00e9 2\" , 15 ] ] print mon_dictionnaire [ \"cl\u00e9 2\" ] #Affiche 15 Tout comme les tableaux, il est possible d'ajouter un couple de valeurs au dictionnaire avec l'action add ou, sans modifier le dictionnaire, l'op\u00e9rateur + : set mon_dictionnaire_vide to dictionnary add [ \"cl\u00e9\" , \"valeur\" ] to mon_dictionnaire_vide print mon_dictionnaire_vide [ \"cl\u00e9\" ] #Affiche \"valeur\" Il est aussi possible de retirer un \u00e9l\u00e9ment du dictionnaire en utilisant l'action remove ou, sans modifier le dictionnaire, avec l'op\u00e9rateur - , avec la cl\u00e9 du couple que l'on veut retirer : set mon_dictionnaire to dictionnary with [ [ \"cl\u00e9 1\" , 14 ] , [ \"cl\u00e9 2\" , 15 ] ] remove \"cl\u00e9 1\" from mon_dictionnaire print mon_dictionnaire #Affiche [ [\"cl\u00e9 2\",15] ] Danger C'est bien la cl\u00e9 qui permet de supprimer un couple !","title":"Les dictionnaires"},{"location":"base/Conditions/","text":"Il est possible de diriger l'ex\u00e9cution d'un script en fonction de certaines conditions . Ainsi, sous r\u00e9serve d'une condition, un ensemble d'instructions peut, ou non, \u00eatre ex\u00e9cut\u00e9. Conditions Les conditions en Sqript reposent sur l'usage des variables de type bool\u00e9en , d\u00e9taill\u00e9es dans la partie variables . Une condition sera v\u00e9rifi\u00e9e si le bool\u00e9en qui lui est pass\u00e9e est de valeur true (vrai, en fran\u00e7ais). Op\u00e9rateurs logiques Il est possible de combiner les valeurs de variables bool\u00e9ennes pour satisfaire une certaine condition. Les op\u00e9rateurs and , or et not permettent d'\u00e9valuer une expression logique en pla\u00e7ant les arguments entre parenth\u00e8ses, autour ou devant les op\u00e9rateurs utilis\u00e9s . Ces op\u00e9rateurs ne fonctionneront pas si les arguments ne sont pas parenth\u00e9s\u00e9s. L'op\u00e9rateur and permet de construire une condition qui sera v\u00e9rifi\u00e9e si deux conditions sont vraies : set mon_booleen to ( 5 = 5 ) and ( 12 = 20 ) print mon_booleen #Affiche False : Les deux conditions n'ont pas \u00e9t\u00e9 v\u00e9rifi\u00e9es De la m\u00eame mani\u00e8re, l'op\u00e9rateur or permet de construire une condition qui sera v\u00e9rifi\u00e9e si au moins une des conditions est vraie : set mon_booleen to ( 5 = 5 ) or ( 12 = 20 ) print mon_booleen #Affiche True : La premi\u00e8re condition a \u00e9t\u00e9 v\u00e9rifi\u00e9e Enfin, l'op\u00e9rateur not correspond \u00e0 la n\u00e9gation logique. Il n'agit que sur une seule variable, envoie false si la variable est vraie, et true si la variable est fausse : set mon_booleen to not ( 5 = 5 ) print mon_booleen #Affiche False : 5 = 5 est True, donc not 5 = 5 est False. Boucle conditionnelle Tip En programmation, une boucle en r\u00e8gle g\u00e9n\u00e9ral est une structure de contr\u00f4le de l'ex\u00e9cution du programme. Il n'est donc pas n\u00e9cessaire que le code dans une boucle soit r\u00e9p\u00e9t\u00e9 plusieurs fois. Pour ex\u00e9cuter un ensemble d'action si une condition est v\u00e9rifi\u00e9e, on utilise la boucle conditionnelle if , \u00e0 laquelle on passe une expression retournant une variable bool\u00e9enne : if < condition > : print \"La condition a \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" On peut y ajouter la boucle else , qui ex\u00e9cutera le code qui lui est associ\u00e9 seulement si la condition pass\u00e9e dans la boucle if n'a pas \u00e9t\u00e9 v\u00e9rifi\u00e9e. if < condition > : print \"La condition a \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" else : print \"La condition n'a pas \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" Enfin, il est possible d'utiliser la boucle else if pour ex\u00e9cuter du code si la condition pass\u00e9e dans la boucle parente n'a pas \u00e9t\u00e9 v\u00e9rifi\u00e9e, mais si une autre condition est v\u00e9rifi\u00e9e. if < condition > : print \"La condition a \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" else if < autre condition > : print \"La condition n'a pas \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" print \"L'autre condition a \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" else : print \"Aucune des conditions n'a \u00e9t\u00e9 v\u00e9rifi\u00e9e\" Danger Les boucles else et else if doivent n\u00e9cessairement \u00eatre plac\u00e9es apr\u00e8s une boucle if ou une boucle else if qui permet de remonter \u00e0 une boucle if . Dans le cas contraire, une erreur sera lev\u00e9e \u00e0 la compilation.","title":"Les conditions"},{"location":"base/Conditions/#conditions","text":"Les conditions en Sqript reposent sur l'usage des variables de type bool\u00e9en , d\u00e9taill\u00e9es dans la partie variables . Une condition sera v\u00e9rifi\u00e9e si le bool\u00e9en qui lui est pass\u00e9e est de valeur true (vrai, en fran\u00e7ais).","title":"Conditions"},{"location":"base/Conditions/#operateurs-logiques","text":"Il est possible de combiner les valeurs de variables bool\u00e9ennes pour satisfaire une certaine condition. Les op\u00e9rateurs and , or et not permettent d'\u00e9valuer une expression logique en pla\u00e7ant les arguments entre parenth\u00e8ses, autour ou devant les op\u00e9rateurs utilis\u00e9s . Ces op\u00e9rateurs ne fonctionneront pas si les arguments ne sont pas parenth\u00e9s\u00e9s. L'op\u00e9rateur and permet de construire une condition qui sera v\u00e9rifi\u00e9e si deux conditions sont vraies : set mon_booleen to ( 5 = 5 ) and ( 12 = 20 ) print mon_booleen #Affiche False : Les deux conditions n'ont pas \u00e9t\u00e9 v\u00e9rifi\u00e9es De la m\u00eame mani\u00e8re, l'op\u00e9rateur or permet de construire une condition qui sera v\u00e9rifi\u00e9e si au moins une des conditions est vraie : set mon_booleen to ( 5 = 5 ) or ( 12 = 20 ) print mon_booleen #Affiche True : La premi\u00e8re condition a \u00e9t\u00e9 v\u00e9rifi\u00e9e Enfin, l'op\u00e9rateur not correspond \u00e0 la n\u00e9gation logique. Il n'agit que sur une seule variable, envoie false si la variable est vraie, et true si la variable est fausse : set mon_booleen to not ( 5 = 5 ) print mon_booleen #Affiche False : 5 = 5 est True, donc not 5 = 5 est False.","title":"Op\u00e9rateurs logiques"},{"location":"base/Conditions/#boucle-conditionnelle","text":"Tip En programmation, une boucle en r\u00e8gle g\u00e9n\u00e9ral est une structure de contr\u00f4le de l'ex\u00e9cution du programme. Il n'est donc pas n\u00e9cessaire que le code dans une boucle soit r\u00e9p\u00e9t\u00e9 plusieurs fois. Pour ex\u00e9cuter un ensemble d'action si une condition est v\u00e9rifi\u00e9e, on utilise la boucle conditionnelle if , \u00e0 laquelle on passe une expression retournant une variable bool\u00e9enne : if < condition > : print \"La condition a \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" On peut y ajouter la boucle else , qui ex\u00e9cutera le code qui lui est associ\u00e9 seulement si la condition pass\u00e9e dans la boucle if n'a pas \u00e9t\u00e9 v\u00e9rifi\u00e9e. if < condition > : print \"La condition a \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" else : print \"La condition n'a pas \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" Enfin, il est possible d'utiliser la boucle else if pour ex\u00e9cuter du code si la condition pass\u00e9e dans la boucle parente n'a pas \u00e9t\u00e9 v\u00e9rifi\u00e9e, mais si une autre condition est v\u00e9rifi\u00e9e. if < condition > : print \"La condition a \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" else if < autre condition > : print \"La condition n'a pas \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" print \"L'autre condition a \u00e9t\u00e9 v\u00e9rifi\u00e9e !\" else : print \"Aucune des conditions n'a \u00e9t\u00e9 v\u00e9rifi\u00e9e\" Danger Les boucles else et else if doivent n\u00e9cessairement \u00eatre plac\u00e9es apr\u00e8s une boucle if ou une boucle else if qui permet de remonter \u00e0 une boucle if . Dans le cas contraire, une erreur sera lev\u00e9e \u00e0 la compilation.","title":"Boucle conditionnelle"},{"location":"base/Evenements/","text":"Un \u00e9v\u00e8nement est un bloc d'actions qui seront ex\u00e9cut\u00e9es lorsque cet \u00e9v\u00e8nement sera appel\u00e9 (ou \"d\u00e9clench\u00e9\"). Plusieurs \u00e9v\u00e8nement sont pris en charge nativement par Sqript, comme par exemple l'\u00e9v\u00e8nement on script load . Pour d\u00e9clencher des actions lorsqu'un \u00e9v\u00e8nement a lieu, il faut cr\u00e9er un nouveau bloc dont l'ent\u00eate contiendra le nom de l'\u00e9v\u00e8nement, suivi de deux points : . Par exemple, cet \u00e9v\u00e8nement affiche \"Hello world !\" lorsque le script est charg\u00e9: on script load : print \"Hello world !\" Chaque \u00e9v\u00e8nement, lorsqu'il est d\u00e9clench\u00e9, permet l'acc\u00e8s \u00e0 des variables qui lui sont propres. Ces variables peuvent \u00eatre obtenues par des accesseurs . Par exemple, l'\u00e9v\u00e8nement on script load permet d'acc\u00e9der \u00e0 l'instance du fichier du script charg\u00e9, via l'accesseur [script] file . Un \u00e9v\u00e8nement peut n'avoir aucun accesseurs. Enfin, lorsqu'un \u00e9v\u00e8nement est annulable , il est possible de le d\u00e9finir comme tel gr\u00e2ce \u00e0 l'action cancel event .","title":"Les \u00e9v\u00e8nements"},{"location":"base/Fonctions/","text":"Une fonction est bloc repr\u00e9sentant un petit bout de code r\u00e9utilisable n'importe o\u00f9, qui peut ou non retourner un r\u00e9sultat. D\u00e9finir une fonction Pour d\u00e9finir une fonction, on utilise le mot cl\u00e9 function puis on indique le prototype de la fonction. Il s'agit de donner le nom de la fonction, puis entre parenth\u00e8ses chacun des param\u00e8tres attendus. Par exemple, cette fonction ne prendra aucun argument et affichera \"Hello world !\" dans la console lors de son ex\u00e9cution. function helloworld (): print \"Hello world !\" Il est possible d'ajouter autant d'arguments que voulu \u00e0 une fonction : function repeat ( text , repetitions ): for i in numbers in range of repetitions : print text Cette fonction r\u00e9p\u00e8tera dans la console le param\u00e8tre texte le nombre de fois donn\u00e9 \u00e0 l'argument repetitions . Pour retourner une valeur, il suffit d'utiliser l'action return : function exp ( a , b ): return a ^ b Ainsi, le r\u00e9sultat peut \u00eatre utilis\u00e9 n'importe o\u00f9 dans les autres actions ou expressions du script : set a to exp ( 2 , 3 ) #a = 8 Danger Attention ! Pour pouvoir appeler une fonction dans une expression ou dans une action, il faut imp\u00e9rativement que la fonction soit d\u00e9clar\u00e9e avant le bloc contenant l'expression ou l'action concern\u00e9e ! Appeler une fonction Pour appeler une fonction, il suffit d'\u00e9crire son nom, puis entre parenth\u00e8ses, chacun des arguments \u00e0 lui donner. Par exemple, ce code affichera le texte \"Loading\" 10 fois dans la console : function repeat ( text , repetitions ): for i in numbers in range of repetitions : print text on script load : repeat ( \"Loading\" , 10 ) Info Les fonctions supportent la r\u00e9cursivit\u00e9. ( ? ) Importer une fonction d'un autre script Pour importer une fonction d'un autre script, il suffit de l'indiquer dans un bloc imports : imports : < nom_de_la_fonction > from < nom_du_script > Le nom du script doit \u00eatre celui donn\u00e9 au fichier, sans l'extension . Pour importer toutes les fonctions d'un script, il suffit d'utiliser le symbole \u00e9toile * au lieu du nom de la fonction. Une fois qu'une fonction est import\u00e9e, elle peut \u00eatre utilis\u00e9e n'importe o\u00f9, de la m\u00eame mani\u00e8re que si elle avait \u00e9t\u00e9 d\u00e9finie dans le fichier du script.","title":"Les fonctions"},{"location":"base/Fonctions/#definir-une-fonction","text":"Pour d\u00e9finir une fonction, on utilise le mot cl\u00e9 function puis on indique le prototype de la fonction. Il s'agit de donner le nom de la fonction, puis entre parenth\u00e8ses chacun des param\u00e8tres attendus. Par exemple, cette fonction ne prendra aucun argument et affichera \"Hello world !\" dans la console lors de son ex\u00e9cution. function helloworld (): print \"Hello world !\" Il est possible d'ajouter autant d'arguments que voulu \u00e0 une fonction : function repeat ( text , repetitions ): for i in numbers in range of repetitions : print text Cette fonction r\u00e9p\u00e8tera dans la console le param\u00e8tre texte le nombre de fois donn\u00e9 \u00e0 l'argument repetitions . Pour retourner une valeur, il suffit d'utiliser l'action return : function exp ( a , b ): return a ^ b Ainsi, le r\u00e9sultat peut \u00eatre utilis\u00e9 n'importe o\u00f9 dans les autres actions ou expressions du script : set a to exp ( 2 , 3 ) #a = 8 Danger Attention ! Pour pouvoir appeler une fonction dans une expression ou dans une action, il faut imp\u00e9rativement que la fonction soit d\u00e9clar\u00e9e avant le bloc contenant l'expression ou l'action concern\u00e9e !","title":"D\u00e9finir une fonction"},{"location":"base/Fonctions/#appeler-une-fonction","text":"Pour appeler une fonction, il suffit d'\u00e9crire son nom, puis entre parenth\u00e8ses, chacun des arguments \u00e0 lui donner. Par exemple, ce code affichera le texte \"Loading\" 10 fois dans la console : function repeat ( text , repetitions ): for i in numbers in range of repetitions : print text on script load : repeat ( \"Loading\" , 10 ) Info Les fonctions supportent la r\u00e9cursivit\u00e9. ( ? )","title":"Appeler une fonction"},{"location":"base/Fonctions/#importer-une-fonction-dun-autre-script","text":"Pour importer une fonction d'un autre script, il suffit de l'indiquer dans un bloc imports : imports : < nom_de_la_fonction > from < nom_du_script > Le nom du script doit \u00eatre celui donn\u00e9 au fichier, sans l'extension . Pour importer toutes les fonctions d'un script, il suffit d'utiliser le symbole \u00e9toile * au lieu du nom de la fonction. Une fois qu'une fonction est import\u00e9e, elle peut \u00eatre utilis\u00e9e n'importe o\u00f9, de la m\u00eame mani\u00e8re que si elle avait \u00e9t\u00e9 d\u00e9finie dans le fichier du script.","title":"Importer une fonction d'un autre script"},{"location":"base/Liste/","text":"Events [item] click [with {item}] [with ((1;left)|(2;right)) hand] ex: [on click on stick:] window setup ex: [on window setup:] player (jump|jumped) ex: [on player jump:] [block] break [of {block}] ex: [on break of stone:] player move[ment] ex: [on player movement:] [of] crosshair[s] bar ex: [on render of crosshair:] [player] send[ing] [a] message ex: [on player sending message:] player (hit|attacked) ex: [on player hit:] render health bar ex: [on render health bar:] render food bar ex: [on render food bar:] (player pickup[s] item|item pickup) ex: [on item pickup:] render overlay ex: [on render overlay:] [block] place [of {block}] ex: [on place of stone:] player (login|connection) ex: [on player login:] [of] (xp|experience) bar ex: [on render xp bar:] (player use[s] item|item use) ex: [on item use:] render [of] player['s] nameplates ex: [on render of player's nameplates:] render chat ex: [on render chat:] on ((1;left)|(2;right)) click on (block [of {block}]|{block}) [with ((3;left)|(4;right)) hand] ex: [on click on block of stone:] [script] load[ed] ex: [on script load:] world tick ex: [on world tick:] Actions shuffle {array} ex: [shuffle array] add elements of {array} to {array} ex: [shuffle array] remove elements of {array} from {array} ex: [shuffle array] sort ((2;elements)|(3;keys)) of {array} [by] [(0;ascending)|(1;descending)] [order] ex: [shuffle array] add {element} to {element} ex: [add 1 to A] remove {element} to {element} ex: [add 1 to A] set {element} to {element} ex: [add 1 to A] send {element} to (console|server) ex: [send arg 1 to sender] send {element} to {element} ex: [send arg 1 to sender] sync {element} as {string} to all players ex: [sync dictionary with [a,b] to player with username \"Player665\" as \"a\"] sync {element} as {string} to {player} ex: [sync dictionary with [a,b] to player with username \"Player665\" as \"a\"] wait {date} ex: [wait 5 seconds] delay {date} ex: [wait 5 seconds] return {element} ex: [return cos(x)] cancel event ex: [return cos(x)] break loop ex: [return cos(x)] break {number} loops ex: [return cos(x)] drop [{+number}] {item} at {array} ex: [drop 1 minecraft:diamond at [11,65,-24]] print {element} ex: [print \"Hello world !\"] draw [(1;shadowed)] text {string} at {array} [with scale {number}] [[and] with color {number}] ex: [draw \"Hello !\" at [0,100] with scale 2] draw colored rect[angle] at {array} with size {array} [and] with color {number} ex: [draw \"Hello !\" at [0,100] with scale 2] draw textured rect[angle] at {array} with size {array} using texture {resource} [with uv {array}] ex: [draw \"Hello !\" at [0,100] with scale 2] draw line from {array} to {array} with stroke {number} [and] with color {number} ex: [draw \"Hello !\" at [0,100] with scale 2] rotate canvas by {number} [((1;degrees)|(2;radians))] ex: [draw \"Hello !\" at [0,100] with scale 2] translate canvas by {array} ex: [draw \"Hello !\" at [0,100] with scale 2] scale canvas by {array} ex: [draw \"Hello !\" at [0,100] with scale 2] push canvas matrix ex: [draw \"Hello !\" at [0,100] with scale 2] pop canvas matrix ex: [draw \"Hello !\" at [0,100] with scale 2] teleport {player} to {array} ex: [teleport player at location at 5 8 9] give [{+number}] {item} to {player} ex: [teleport player at location at 5 8 9] kick {player} [with message {string}] ex: [teleport player at location at 5 8 9] Expressions {element} formatted as {string}:string ex: [5.643 formatted as \"--,--\"] random (number|([float] number)|float) [between {number} and {number}]:number ex: [random integer between 0 and 10] random (integer|(integer number)|int) between {number} and {number}:number ex: [random integer between 0 and 10] all players:array ex: [location of player] player (named|with username) {string}:player ex: [location of player] {+player}['s] name:player ex: [location of player] {+player}['s] health:number ex: [location of player] {+player}['s] (hunger|food):number ex: [location of player] {+player}['s] look vector:vector ex: [location of player] x coord[inate] of {array}:number ex: [x coordinate of [1,50,6]] y coord[inate] of {array}:number ex: [x coordinate of [1,50,6]] z coord[inate] of {array}:number ex: [x coordinate of [1,50,6]] location of {element}|{+element}'s location: array ex: [x coordinate of [1,50,6]] distance between {element} and {element}:number ex: [x coordinate of [1,50,6]] vector of {array}|{array} vector:vector ex: [x coordinate of [1,50,6]] block at {array} [in world {number}]:block ex: [block at [15,65,-25]] blocks in radius {number} around {element} [in world {number}]:array ex: [block at [15,65,-25]] value {string} is synced:boolean ex: [synced value test] synced value {string}:element ex: [synced value test] screen width:number ex: [screen width] screen height:number ex: [screen width] screen width of {string}:number ex: [screen width] screen height of font:number ex: [screen width] console|server:sender ex: [console] [a] [new] dictionary:dictionary ex: [dictionary[\"key\"]] dictionary with {array*}:dictionary ex: [dictionary[\"key\"]] [{number} year[s]] [[and] {number} month[s]] [[and] {number} week[s]] [[and] {number} day[s]] [[and] {number} hour[s]] [[and] {number} minute[s]] [[and] {number} second[s]] [[and] {number} tick[s]] [[and] {number} (millisecond[s]|ms)] ex: [15 minutes and 4 seconds] now ex: [15 minutes and 4 seconds] [execution] side:string ex: [execution side] window (name|title):string ex: [execution side] window icons:array ex: [execution side] ~[{element*}~]:array ex: [size of array] size of {array}:number ex: [size of array] [a] random element of {array}:element ex: [size of array] first element of {array}:element ex: [size of array] last element of {array}:element ex: [size of array] {+array}~[{+number}~]:element ex: [size of array] numbers from {number} to {number}:array ex: [size of array] [numbers] in range of {number}:array ex: [size of array] random numbers in range of {number}:array ex: [size of array] {element} is in {array}:boolean ex: [size of array] {element} is not in {array}:boolean ex: [size of array] {array} contains {element}:boolean ex: [size of array] sorted [(0;ascending)|(1;descending)] ((2;elements)|(3;keys)) of {array}:array ex: [size of array] copy of {array}:array ex: [size of array] type of {element}:string ex: [type of \"test\"] {element} parsed as {string}:element ex: [type of \"test\"] {element} is (set|defined):boolean ex: [type of \"test\"] {element} is not (set|defined):boolean ex: [type of \"test\"] Blocks event ex: Event blocks on player death: import ex: Import blocks import: time loop ex: Time looping blocks every 1 day: item ex: item blocks item my_item: packet ex: Network packet blocks packet frame1_packet(parameter): function ex: Function blocks function isEven(x): command ex: Command blocks command /heal: options ex: Options block options:","title":"Listes des \u00e9v\u00e8nements, actions, expressions et blocs impl\u00e9ment\u00e9s"},{"location":"base/Options/","text":"Les options sont un ensemble de param\u00e8tres d\u00e9finis de mani\u00e8re globale dans un script. Elles permettent de faciliter la configuration d'un script pour modifier son fonctionnement. D\u00e9finir une option Pour cr\u00e9er une option, il suffit de l'inclure dans un bloc d\u00e9finit par options: : options : mon_option : 5 Une option peut prendre n'importe quelle valeur, il peut \u00e9galement s'agir d'un tableau, ou de n'importe quel type de variable, tant qu'elle peut \u00eatre d\u00e9finie en dehors d'un contexte d'ex\u00e9cution . Warning Le nom de l'option ne doit pas contenir d'espaces ni de caract\u00e8res sp\u00e9ciaux. Il ne peut \u00eatre constitu\u00e9 que par des lettres non accentu\u00e9es, des nombres ou l' underscore _ . Obtenir la valeur d'une option Pour r\u00e9cup\u00e9rer la valeur d'une option, il suffit d'utiliser l'arobase @ suivie du nom de l'option : options : mon_option : 5 on script load : print @mon_option #Affiche 5","title":"Les options"},{"location":"base/Options/#definir-une-option","text":"Pour cr\u00e9er une option, il suffit de l'inclure dans un bloc d\u00e9finit par options: : options : mon_option : 5 Une option peut prendre n'importe quelle valeur, il peut \u00e9galement s'agir d'un tableau, ou de n'importe quel type de variable, tant qu'elle peut \u00eatre d\u00e9finie en dehors d'un contexte d'ex\u00e9cution . Warning Le nom de l'option ne doit pas contenir d'espaces ni de caract\u00e8res sp\u00e9ciaux. Il ne peut \u00eatre constitu\u00e9 que par des lettres non accentu\u00e9es, des nombres ou l' underscore _ .","title":"D\u00e9finir une option"},{"location":"base/Options/#obtenir-la-valeur-dune-option","text":"Pour r\u00e9cup\u00e9rer la valeur d'une option, il suffit d'utiliser l'arobase @ suivie du nom de l'option : options : mon_option : 5 on script load : print @mon_option #Affiche 5","title":"Obtenir la valeur d'une option"},{"location":"base/Structure/","text":"Un script est d\u00e9fini par un unique fichier, dont l'extension est .sq . Chaque fichier poss\u00e9dant cette extension dans le dossier .minecraft/scripts/ correspondra donc \u00e0 un script. Info Il est conseill\u00e9 d'utiliser un \u00e9diteur de texte performant pour faciliter ou automatiser certaines t\u00e2ches lors de la r\u00e9daction d'un script. Pour fonctionner correctement, un script doit respecter une certaine structure . Un script fonctionnel est compos\u00e9 de blocs . Un bloc est un ensemble de lignes ayant un certain r\u00f4le lors de l'ex\u00e9cution du script, et constitue l'\u00e9l\u00e9ment le plus important dans un script. Un bloc peut ex\u00e9cuter des actions , d\u00e9finir des valeurs, ou indiquer \u00e0 Sqript comment se comporter avec les autres blocs. Voici un exemple de structure par blocs : Tip Pour l'instant, on ignorera le contenu des blocs. Tout sera expliqu\u00e9 dans les parties suivantes. Un bloc peut contenir des sauts de lignes, Sqript consid\u00e9rera qu'un bloc s'arr\u00eate que lorsqu'un nouveau bloc commence ou lorsqu'on arrive \u00e0 la fin du fichier. On remarquera qu'un nouveau bloc est d\u00e9fini par une premi\u00e8re ligne dont l' indentation vaut z\u00e9ro. Info L' indentation d'une ligne correspond au nombre de tabulations pr\u00e9sentes au d\u00e9but de la ligne. Pour indenter une ligne, on peut utiliser la touche ++tab++, ou ajouter 4 espaces. Warning Il est bien pr\u00e9cis\u00e9 ci-dessus que 4 espaces sont n\u00e9cessaires, si un espace est oubli\u00e9 l'indentation sera mauvaise. Si un script est mal indent\u00e9, de nombreuses erreurs peuvent se produire. Il est donc conseill\u00e9 d'utiliser un \u00e9diteur de texte permettant une manipulation efficace et intuitive des tabulations ( Sublime Text 3 ).","title":"La structure d'un sqript"},{"location":"base/Variables/","text":"En programmation, en r\u00e8gle g\u00e9n\u00e9rale, on utilise des variables pour manipuler notre programme. Un script \u00e9tant comme un petit programme, l'utilisation des variables est in\u00e9vitable. Par-del\u00e0 leur nom un peu barbare pour ceux qui n'y sont pas habitu\u00e9s, leur usage est facile et intuitif. Variables Une variable consiste en une bo\u00eete contenant une valeur , et portant un nom . Ainsi, on peut r\u00e9cup\u00e9rer la valeur contenue dans la bo\u00eete gr\u00e2ce \u00e0 son nom, tr\u00e8s facilement. En pratique, on utilisera l'action set . Celle ci s'utilise de la mani\u00e8re suivante : set < nom > to < valeur > On peut par exemple d\u00e9finir une variable appel\u00e9e age dont la valeur sera 18 de la mani\u00e8re suivante : set age to 18 Tip Le nom d'une variable ne doit pas contenir d'espaces. Il peut contenir des accents, mais pour \u00e9viter des \u00e9ventuels probl\u00e8mes lors de l'encodage du fichier, il est pr\u00e9f\u00e9rable de les \u00e9viter. Cette variable peut maintenant \u00eatre utilis\u00e9e plus ou moins n'importe o\u00f9 dans le bloc o\u00f9 elle a \u00e9t\u00e9 d\u00e9finie . Par exemple, on peut l'afficher dans la console gr\u00e2ce \u00e0 l'action print en utilisant directement son nom : print age #Affichera 18 dans la console. Tip Le code apr\u00e8s le symbole # est ignor\u00e9 : il s'agit d'un commentaire . Tout texte pr\u00e9c\u00e9d\u00e9 d'un tel symbole sera ignor\u00e9 par Sqript . Cela permet d'ajouter des pr\u00e9cisions sur son code et ainsi le rendre plus lisible par soi-m\u00eame, et par les autres. Variables globales Il est possible d'enregistrer des variables qui seront utilisables partout, dans n'importe quel autre partie du script, ainsi que dans tous les autres scripts. Pour indiquer qu'une variable est globale, il suffit d'ajouter le symbole $ devant le nom de la variable. Ces variables seront \u00e9galement enregistr\u00e9es dans un fichier ( /scripts/data.dat ) et seront sauvegard\u00e9es lors des red\u00e9marrages de Sqript, si leur type supporte la sauvegarde (s'ils sont s\u00e9rialisables ) Tip Les dictionnaires sont s\u00e9rialisables. Pour cr\u00e9er des variables avec des nom dynamiques (par exemple propre \u00e0 chaque joueur), il peut \u00eatre int\u00e9ressant d'utiliser un dictionnaire. Tip Le comportement des variables globales est similaire aux variables du plugin Skript pour les habitu\u00e9s. Types Chaque valeur contenue par une variable poss\u00e8de un certain type. Par exemple, la variable age ci-dessus est un nombre . Il existe de nombreux types. Nombres Les nombres sont les objets les plus manipul\u00e9s en r\u00e8gle g\u00e9n\u00e9rale dans un programme. Ils peuvent \u00eatre d\u00e9finis dans un script en les \u00e9crivant directement, ou en les exprimant selon une expression math\u00e9matique (voir les op\u00e9rateurs ) pouvant int\u00e9grer directement des variables d\u00e9finies plus haut: set a to 5.6 set b to 2 set resultat to a * b #5.6 \u00d7 2 = 11.2 print resultat #Affiche 11.2 Tip Il est possible d'utiliser des nombres \u00e0 virgules, mais il faut veiller \u00e0 utiliser le point . et non pas la virgule , ! Cha\u00eenes de caract\u00e8res En dehors des nombres, le plus utilis\u00e9 est certainement la cha\u00eene de caract\u00e8res . Il s'agit d'une suite de caract\u00e8res, d\u00e9finie entre guillemets . D\u00e9finissons par exemple la variable prenom \u00e0 Louis : set prenom to \"Louis\" On peut mettre ce que l'on veut entre les guillemets. Il peut y avoir des espaces, des caract\u00e8res sp\u00e9ciaux ( veiller \u00e0 l'encodage ! ) ou des nombres. Pour inclure des guillemets dans notre cha\u00eene de caract\u00e8re, il faut les \u00e9chapper . Cela indique \u00e0 Sqript qu'il ne faut pas interpr\u00e9ter ce guillemet comme la fin de la cha\u00eene. Pour \u00e9chapper un guillemet, on le pr\u00e9c\u00e8de d'un antislash : \\ . Ce qui donnerait : set presentation to \"Je m'appelle \\\"Louis\\\"\" . Il est possible de concat\u00e9ner les cha\u00eenes de caract\u00e8res entre elles en utilisant l'addition : print \"Chaine 1 \" + \"Chaine 2\" #Affiche Chaine 1 Chaine 2 Bool\u00e9ens Enfin, parmi les types primitifs \u00e0 conna\u00eetre, il y a les bool\u00e9ens . Les bool\u00e9ens sont des variables pouvant prendre uniquement deux valeurs : true ou false (respectivement vrai et faux en fran\u00e7ais). Elle sont tr\u00e8s utiles car on peut les manipuler avec certains op\u00e9rateurs pour \u00e9tablir une certaine logique d'ex\u00e9cution de notre script en utilisant les conditions . set mon_booleen to false Op\u00e9rateurs Les variables peuvent \u00eatre manipul\u00e9es par des op\u00e9rateurs ( + * - / ...). C'est le type de la variable ( le type de la valeur de la variable ) qui d\u00e9finit comment se comporte la variable avec chaque op\u00e9rateur. Il se peut qu'un type n'ait aucune d\u00e9finition pour un certain op\u00e9rateur, dans ce cas, une erreur sera lev\u00e9e lors de la compilation. Il se peut \u00e9galement qu'un type ait une d\u00e9finition pour un op\u00e9rateur, mais que pour un certain autre type de valeur. Dans ce cas, il faudra veiller au typage de nos variables. Par exemple : print 5 - 9 + 2 #Affiche -2 print \"Bonjour !\" + 26 #Affiche Bonjour ! 26 print \"Bonjour !\" + \"Au revoir !\" #Affiche Bonjour ! Au revoir ! print \"Bonjour !\" - \"Au revoir !\" #N'a pas de sens, l\u00e8vera une erreur Certains op\u00e9rateurs combinent deux valeurs d'un m\u00eame type et donnent une valeur d'un type diff\u00e9rent. C'est le cas de l'op\u00e9rateur = qui renvoie un bool\u00e9en lorsqu'il est utilis\u00e9 avec deux nombres : print 8 = 10 #Affiche False Pour les nombres, les op\u00e9rateurs communs sont impl\u00e9ment\u00e9s par Sqript. En voici une liste non exhaustive : Symbole Description + Addition - Soustraction * Multiplication / Division ! Factorielle ( ? ) ^ Exponentiation ( Puissance ) <= Inf\u00e9rieur ou \u00e9gal \u00e0 < Inf\u00e9rieur \u00e0 >= Sup\u00e9rieur ou \u00e9gal \u00e0 > Sup\u00e9rieur \u00e0 = \u00c9gal \u00e0 Warning Toute erreur de parenth\u00e9sage l\u00e8vera une erreur lors de la compilation","title":"Les variables"},{"location":"base/Variables/#variables","text":"Une variable consiste en une bo\u00eete contenant une valeur , et portant un nom . Ainsi, on peut r\u00e9cup\u00e9rer la valeur contenue dans la bo\u00eete gr\u00e2ce \u00e0 son nom, tr\u00e8s facilement. En pratique, on utilisera l'action set . Celle ci s'utilise de la mani\u00e8re suivante : set < nom > to < valeur > On peut par exemple d\u00e9finir une variable appel\u00e9e age dont la valeur sera 18 de la mani\u00e8re suivante : set age to 18 Tip Le nom d'une variable ne doit pas contenir d'espaces. Il peut contenir des accents, mais pour \u00e9viter des \u00e9ventuels probl\u00e8mes lors de l'encodage du fichier, il est pr\u00e9f\u00e9rable de les \u00e9viter. Cette variable peut maintenant \u00eatre utilis\u00e9e plus ou moins n'importe o\u00f9 dans le bloc o\u00f9 elle a \u00e9t\u00e9 d\u00e9finie . Par exemple, on peut l'afficher dans la console gr\u00e2ce \u00e0 l'action print en utilisant directement son nom : print age #Affichera 18 dans la console. Tip Le code apr\u00e8s le symbole # est ignor\u00e9 : il s'agit d'un commentaire . Tout texte pr\u00e9c\u00e9d\u00e9 d'un tel symbole sera ignor\u00e9 par Sqript . Cela permet d'ajouter des pr\u00e9cisions sur son code et ainsi le rendre plus lisible par soi-m\u00eame, et par les autres.","title":"Variables"},{"location":"base/Variables/#variables-globales","text":"Il est possible d'enregistrer des variables qui seront utilisables partout, dans n'importe quel autre partie du script, ainsi que dans tous les autres scripts. Pour indiquer qu'une variable est globale, il suffit d'ajouter le symbole $ devant le nom de la variable. Ces variables seront \u00e9galement enregistr\u00e9es dans un fichier ( /scripts/data.dat ) et seront sauvegard\u00e9es lors des red\u00e9marrages de Sqript, si leur type supporte la sauvegarde (s'ils sont s\u00e9rialisables ) Tip Les dictionnaires sont s\u00e9rialisables. Pour cr\u00e9er des variables avec des nom dynamiques (par exemple propre \u00e0 chaque joueur), il peut \u00eatre int\u00e9ressant d'utiliser un dictionnaire. Tip Le comportement des variables globales est similaire aux variables du plugin Skript pour les habitu\u00e9s.","title":"Variables globales"},{"location":"base/Variables/#types","text":"Chaque valeur contenue par une variable poss\u00e8de un certain type. Par exemple, la variable age ci-dessus est un nombre . Il existe de nombreux types.","title":"Types"},{"location":"base/Variables/#nombres","text":"Les nombres sont les objets les plus manipul\u00e9s en r\u00e8gle g\u00e9n\u00e9rale dans un programme. Ils peuvent \u00eatre d\u00e9finis dans un script en les \u00e9crivant directement, ou en les exprimant selon une expression math\u00e9matique (voir les op\u00e9rateurs ) pouvant int\u00e9grer directement des variables d\u00e9finies plus haut: set a to 5.6 set b to 2 set resultat to a * b #5.6 \u00d7 2 = 11.2 print resultat #Affiche 11.2 Tip Il est possible d'utiliser des nombres \u00e0 virgules, mais il faut veiller \u00e0 utiliser le point . et non pas la virgule , !","title":"Nombres"},{"location":"base/Variables/#chaines-de-caracteres","text":"En dehors des nombres, le plus utilis\u00e9 est certainement la cha\u00eene de caract\u00e8res . Il s'agit d'une suite de caract\u00e8res, d\u00e9finie entre guillemets . D\u00e9finissons par exemple la variable prenom \u00e0 Louis : set prenom to \"Louis\" On peut mettre ce que l'on veut entre les guillemets. Il peut y avoir des espaces, des caract\u00e8res sp\u00e9ciaux ( veiller \u00e0 l'encodage ! ) ou des nombres. Pour inclure des guillemets dans notre cha\u00eene de caract\u00e8re, il faut les \u00e9chapper . Cela indique \u00e0 Sqript qu'il ne faut pas interpr\u00e9ter ce guillemet comme la fin de la cha\u00eene. Pour \u00e9chapper un guillemet, on le pr\u00e9c\u00e8de d'un antislash : \\ . Ce qui donnerait : set presentation to \"Je m'appelle \\\"Louis\\\"\" . Il est possible de concat\u00e9ner les cha\u00eenes de caract\u00e8res entre elles en utilisant l'addition : print \"Chaine 1 \" + \"Chaine 2\" #Affiche Chaine 1 Chaine 2","title":"Cha\u00eenes de caract\u00e8res"},{"location":"base/Variables/#booleens","text":"Enfin, parmi les types primitifs \u00e0 conna\u00eetre, il y a les bool\u00e9ens . Les bool\u00e9ens sont des variables pouvant prendre uniquement deux valeurs : true ou false (respectivement vrai et faux en fran\u00e7ais). Elle sont tr\u00e8s utiles car on peut les manipuler avec certains op\u00e9rateurs pour \u00e9tablir une certaine logique d'ex\u00e9cution de notre script en utilisant les conditions . set mon_booleen to false","title":"Bool\u00e9ens"},{"location":"base/Variables/#operateurs","text":"Les variables peuvent \u00eatre manipul\u00e9es par des op\u00e9rateurs ( + * - / ...). C'est le type de la variable ( le type de la valeur de la variable ) qui d\u00e9finit comment se comporte la variable avec chaque op\u00e9rateur. Il se peut qu'un type n'ait aucune d\u00e9finition pour un certain op\u00e9rateur, dans ce cas, une erreur sera lev\u00e9e lors de la compilation. Il se peut \u00e9galement qu'un type ait une d\u00e9finition pour un op\u00e9rateur, mais que pour un certain autre type de valeur. Dans ce cas, il faudra veiller au typage de nos variables. Par exemple : print 5 - 9 + 2 #Affiche -2 print \"Bonjour !\" + 26 #Affiche Bonjour ! 26 print \"Bonjour !\" + \"Au revoir !\" #Affiche Bonjour ! Au revoir ! print \"Bonjour !\" - \"Au revoir !\" #N'a pas de sens, l\u00e8vera une erreur Certains op\u00e9rateurs combinent deux valeurs d'un m\u00eame type et donnent une valeur d'un type diff\u00e9rent. C'est le cas de l'op\u00e9rateur = qui renvoie un bool\u00e9en lorsqu'il est utilis\u00e9 avec deux nombres : print 8 = 10 #Affiche False Pour les nombres, les op\u00e9rateurs communs sont impl\u00e9ment\u00e9s par Sqript. En voici une liste non exhaustive : Symbole Description + Addition - Soustraction * Multiplication / Division ! Factorielle ( ? ) ^ Exponentiation ( Puissance ) <= Inf\u00e9rieur ou \u00e9gal \u00e0 < Inf\u00e9rieur \u00e0 >= Sup\u00e9rieur ou \u00e9gal \u00e0 > Sup\u00e9rieur \u00e0 = \u00c9gal \u00e0 Warning Toute erreur de parenth\u00e9sage l\u00e8vera une erreur lors de la compilation","title":"Op\u00e9rateurs"},{"location":"fonc/Action/","text":"Pour cr\u00e9er une nouvelle action, la m\u00e9thode est sensiblement la m\u00eame que pour une expression. La classe cr\u00e9\u00e9e doit h\u00e9riter de ScriptAction et l'annotation doit \u00eatre @Action . Les param\u00e8tres ont exactement les m\u00eames fonctions que ceux de l'annotation @Expression , vous pouvez vous y r\u00e9f\u00e9rerer ici : Expressions . Il n'y a qu'une m\u00e9thode abstraite de la classe m\u00e8re \u00e0 impl\u00e9menter : execute(ScriptContext) . De la m\u00eame mani\u00e8re que pour les expressions, il est possible d'obtenir l'indice du pattern reconnu gr\u00e2ce au param\u00e8tre matchedIndex . De m\u00eame, les param\u00e8tres configur\u00e9s dans les patterns sont accessibles via la liste getParameters() . En plus de la m\u00e9thode execute() , il est possible de directement modifier le comportement de la lecture du script en modifiant le prochain \u00e9l\u00e9ment \u00e0 ex\u00e9cuter apr\u00e8s l'ex\u00e9cution de cette action. En surchargeant la m\u00e9thode getNext() et en modifiant la valeur de retour \u00e0 null , l'ex\u00e9cution du bloc en cours s'arr\u00eatera \u00e0 la fin de l'ex\u00e9cution de l'action, et reprendra au bloc parent de l'action. Le script peut \u00eatre totalement arr\u00eat\u00e9 en surchargeant la m\u00e9thode getParent() et en modifiant la valeur de retour \u00e0 null \u00e9galement. Tip C'est sur cette m\u00e9thode que repose l'action return , par exemple. Vous pouvez aussi rediriger l'ex\u00e9cution du script, mais cela demande plus d'exp\u00e9rience et de compr\u00e9hension du mode de fonctionnement de Sqript. Voici un exemple d'action, celle-ci affichant dans la console n'importe quel \u00e9l\u00e9ment : @Action ( name = \"Print\" , description = \"Print something in console\" , examples = \"print \\\"Hello world !\\\"\" , patterns = \"print {element}\" ) public class ActPrint extends ScriptAction { @Override public void execute ( ScriptContext context ) { ScriptExpression firstParameter = getParameters (). get ( 0 ); //On peut acc\u00e9der aux \u00e9l\u00e9ments du contexte depuis le code java \u00e9galement. ScriptManager . log . info ( context . get ( \"script file\" ) + \" : \" + firstParameter . get ( context )); } }","title":"Ajouter une action"},{"location":"fonc/Bloc/","text":"Les blocs permettent de d\u00e9cupler les possibilit\u00e9s de Sqript, mais seront de fait les objets les plus abstraits et les plus difficiles \u00e0 manipuler. Pour cr\u00e9er un bloc, il suffit de cr\u00e9er une classe qui h\u00e9rite de ScriptBlock et y ajouter l'annotation @Block , puis la remplir. Les blocs sont reconnus automatiquement au d\u00e9marrage de Sqript, et le constructeur de votre classe sera appel\u00e9 si le Regex pass\u00e9 dans l'annotation a \u00e9t\u00e9 reconnu lors de la lecture de la premi\u00e8re ligne du bloc . Cette ligne sera appel\u00e9e l'ent\u00eate du bloc. Lors de la lecture du bloc, plusieurs sous-blocs vont \u00eatre g\u00e9n\u00e9r\u00e9s par Sqript, et donn\u00e9s \u00e0 votre objet ScriptBlock. Pour les configurer, il suffit de les ajouter \u00e0 la liste fields() de l'annotation @Block . Si votre bloc n'a pas de structure particuli\u00e8re (contrairement au bloc command , auquel on peut donner une description, ou des aliases par exemple), tout le contenu de votre bloc sera dans l'objet mainField , contenant tout ce que contient votre bloc. Libre \u00e0 vous de travailler avec ces lignes comme il vous semble. Il est possible de compiler ces lignes gr\u00e2ce \u00e0 la m\u00e9thode compile de votre mainField , puis gr\u00e2ce \u00e0 la m\u00e9thode createCompileGroup() \u00e0 donner en argument de la m\u00e9thode pr\u00e9c\u00e9dente. Pour des structures de blocs plus complexes, il est possible de r\u00e9cup\u00e9rer des sous blocs particuliers en utilisant ce code tr\u00e8s simple (ici extrait de la classe du bloc command ) : if ( fieldDefined ( \"description\" )) this . setDescription ( getSubBlock ( \"description\" ). getRawHead ()); Les m\u00e9thodes les plus importantes \u00e9tant fieldDefined(String) et getSubBlock(String) . La m\u00e9thode getRawHead() renvoie en cha\u00eene de caract\u00e8res brute l'ent\u00eate du sous-block \u00e0 laquelle on a enlev\u00e9 le nom du sous bloc (ici \"description\") suivi de deux points \":\" . Voici un exemple, la classe du bloc message qui permet d'\u00e9changer des informations entre le c\u00f4t\u00e9 client et le c\u00f4t\u00e9 serveur : @Block ( name = \"message\" , description = \"Network messages blocks\" , examples = \"message frame1_messages(parameter):\" , regex = \"^message .*\" , side = Side . BOTH , fields = { \"client\" , \"server\" } ) public class ScriptBlockMessage extends ScriptFunctionalBlock { //Les IScript \u00e0 ex\u00e9cuter en fonction du side de r\u00e9ception IScript client = null ; IScript server = null ; public IScript getClient () { return client ; } public IScript getServer () { return server ; } @SideOnly ( net . minecraftforge . fml . relauncher . Side . CLIENT ) @Override public ScriptType get ( ScriptContext context , ScriptType <?>[] parameters ) throws ScriptException { return new TypeMessagePrototype ( new ScriptMessage ( this . name , parameters )); } public ScriptBlockMessage ( ScriptLine head ) throws ScriptException { super ( head ); } @Override protected void load () throws Exception { ScriptCompileGroup group = createCompileGroup (); //Compilation des fields \"client\" et \"server\" if ( fieldDefined ( \"client\" )){ client = getSubBlock ( \"client\" ). compile ( group ); } if ( fieldDefined ( \"server\" )){ server = getSubBlock ( \"server\" ). compile ( group ); } //On enregistre le message fra\u00eechement cr\u00e9\u00e9, pour qu'il soit reconnu par le reste du script. ScriptNetworkManager . registerMessage ( this ); } }","title":"Ajouter un bloc"},{"location":"fonc/Conventions/","text":"L'enregistrement de certains \u00e9l\u00e9ments passe par une annotation de classe. Cette annotation, qu'elle soit @Event , @Expression , @Action ou encore @Native demande des param\u00e8tres sp\u00e9cifiques permettent d'identifier chaque nouvel \u00e9l\u00e9ment. Cependant, certains param\u00e8tres ne sont utiles que pour permettre une meilleure documentation ainsi qu'un meilleure lecture du code. C'est le cas le plus souvent pour les param\u00e8tres name , description et examples . Nom des \u00e9l\u00e9ments Chaque classe permettant la reconnaissance de plusieurs patterns (sauf pour les \u00e9v\u00e8nements ), il est recommand\u00e9 de configurer le param\u00e8tre name de la mani\u00e8re suivante : name = \"Ce sur quoi agit la classe de mani\u00e8re g\u00e9n\u00e9rale\" + \"<Type de l'\u00e9l\u00e9ment>\" Par exemple, pour les fonctions math\u00e9matiques, on configure name \u00e0 \"Math Functions\" . Pour les expressions agissant sur les tableaux, on configure name \u00e0 \"Arrays Expressions\" . Description des \u00e9l\u00e9ments Aucune particularit\u00e9 n'est demand\u00e9e ici. Il faut simplement \u00eatre le plus concis et le plus clair possible, pour qu'il soit possible de comprendre ce que fait cette classe. Examples des \u00e9l\u00e9ments En ce qui concerne les exemples, vous pouvez en mettre autant que vous voulez, mais il est inutile d'en fournir un pour chaque pattern. L'id\u00e9e est de montrer un r\u00e9sum\u00e9 de ce qu'il est possible de faire, sur 5 ou 6 patterns. On pr\u00e9f\u00e9rera ne pas ins\u00e9rer de phrases dans les exemples, ou de commentaires, simplement du code qu'il est possible d'ajouter \u00e0 un script.","title":"Les conventions"},{"location":"fonc/Conventions/#nom-des-elements","text":"Chaque classe permettant la reconnaissance de plusieurs patterns (sauf pour les \u00e9v\u00e8nements ), il est recommand\u00e9 de configurer le param\u00e8tre name de la mani\u00e8re suivante : name = \"Ce sur quoi agit la classe de mani\u00e8re g\u00e9n\u00e9rale\" + \"<Type de l'\u00e9l\u00e9ment>\" Par exemple, pour les fonctions math\u00e9matiques, on configure name \u00e0 \"Math Functions\" . Pour les expressions agissant sur les tableaux, on configure name \u00e0 \"Arrays Expressions\" .","title":"Nom des \u00e9l\u00e9ments"},{"location":"fonc/Conventions/#description-des-elements","text":"Aucune particularit\u00e9 n'est demand\u00e9e ici. Il faut simplement \u00eatre le plus concis et le plus clair possible, pour qu'il soit possible de comprendre ce que fait cette classe.","title":"Description des \u00e9l\u00e9ments"},{"location":"fonc/Conventions/#examples-des-elements","text":"En ce qui concerne les exemples, vous pouvez en mettre autant que vous voulez, mais il est inutile d'en fournir un pour chaque pattern. L'id\u00e9e est de montrer un r\u00e9sum\u00e9 de ce qu'il est possible de faire, sur 5 ou 6 patterns. On pr\u00e9f\u00e9rera ne pas ins\u00e9rer de phrases dans les exemples, ou de commentaires, simplement du code qu'il est possible d'ajouter \u00e0 un script.","title":"Examples des \u00e9l\u00e9ments"},{"location":"fonc/Evenements/","text":"Cr\u00e9er l'\u00e9v\u00e8nement Pour cr\u00e9er un nouvel \u00e9v\u00e8nement, commencer par cr\u00e9er une nouvelle classe qui h\u00e9ritera de la classe ScriptEvent . Le constructeur de la classe ScriptEvent est ce qui va permettre de passer des variables au contexte local de l'\u00e9v\u00e8nement lorsqu'il sera d\u00e9clench\u00e9. Par exemple, l'\u00e9v\u00e8nement suivant donne acc\u00e8s au fichier du script qui vient d'\u00eatre charg\u00e9 : public class EvtOnScriptLoad extends ScriptEvent { public EvtOnScriptLoad ( File scriptFile ) { super ( new ScriptAccessor ( new TypeFile ( scriptFile ), \"[script] file\" )); } } Le constructeur EvtOnScriptLoad peut prendre n'importe quels arguments en param\u00e8tres. C'est ce constructeur qui sera appel\u00e9 lorsqu'il faudra d\u00e9clencher l'\u00e9v\u00e8nement. Le constructeur super accepte une infinit\u00e9 d'instances du type ScriptAccessor . Pour rappel, les ScriptAccessor sont des objets qui contiennent un \u00e9l\u00e9ment de n'importe quel type , ainsi qu'un pattern RegEx . En utilisant le constructeur de ScriptAccessor , on peut transformer un pattern en RegEx facilement. Ici, l'accesseur reconna\u00eetra les expressions \"file\" et \"script file\", et retournera le TypeFile() nouvellement instanci\u00e9. Il faut maintenant enregistrer l'\u00e9v\u00e8nement. Il suffit pour cela d'ajouter l'annotation @Event \u00e0 la classe cr\u00e9\u00e9e, puis de remplir les param\u00e8tres demand\u00e9s. Les patterns permettront de reconna\u00eetre l'\u00e9v\u00e8nement lors de la lecture de la ligne. Par exemple, le pattern [script] load[ed] reconna\u00eetra les lignes \"load\", \"script load\", \"script loaded\" et \"loaded\". Enfin, le param\u00e8tre accessors permet d'indiquer au syst\u00e8me de compilation quels accesseurs cet \u00e9v\u00e8nement poss\u00e8de. Voici une classe d'\u00e9v\u00e8nement compl\u00e8te : @Event ( name = \"script load\" , description = \"Called when script is loaded\" , examples = \"on script load:\" , patterns = \"[script] load[ed]\" , accessors = \"[script] file:file\" ) public class EvtOnScriptLoad extends ScriptEvent { public EvtOnScriptLoad ( File scriptFile ) { super ( new ScriptAccessor ( new TypeFile ( scriptFile ), \"[script] file\" )); } } D\u00e9clencher l'\u00e9v\u00e8nement Une fois que l'\u00e9v\u00e8nement est enregistr\u00e9, il est possible de l'appeler depuis n'importe quel m\u00e9thode ou fonction java. Pour cela, il suffit d'appeler la m\u00e9thode ScriptManager.callEvent(ScriptEvent) . L'argument ScriptEvent sera simplement une instance de votre classe. Par exemple, pour d\u00e9clencher l'\u00e9v\u00e8nement d\u00e9finit par la classe ci-dessus, la fonction serait appel\u00e9e comme suit : ScriptManager . callEvent ( new EvtOnScriptLoad ( script_file )); Dans ce cas, toutes les instances de scripts recevront l'\u00e9v\u00e8nement. Cette m\u00e9thode retournera true si l'\u00e9v\u00e8nement a \u00e9t\u00e9 annul\u00e9 par un script. Tip Pour cibler un script en particulier, il suffit d'appeler la m\u00eame m\u00e9thode de l'instance de ScriptInstance du script. Pour r\u00e9cup\u00e9rer le contexte apr\u00e8s ex\u00e9cution du script, par exemple si on veut savoir la valeur d'un des accesseurs apr\u00e8s ex\u00e9cution, il suffit d'appeler la m\u00e9thode ScriptManager.callEventAndGetContext(ScriptEvent) . Une instance du ScriptContext vous sera alors renvoy\u00e9e.","title":"Ajouter un \u00e9v\u00e8nement"},{"location":"fonc/Evenements/#creer-levenement","text":"Pour cr\u00e9er un nouvel \u00e9v\u00e8nement, commencer par cr\u00e9er une nouvelle classe qui h\u00e9ritera de la classe ScriptEvent . Le constructeur de la classe ScriptEvent est ce qui va permettre de passer des variables au contexte local de l'\u00e9v\u00e8nement lorsqu'il sera d\u00e9clench\u00e9. Par exemple, l'\u00e9v\u00e8nement suivant donne acc\u00e8s au fichier du script qui vient d'\u00eatre charg\u00e9 : public class EvtOnScriptLoad extends ScriptEvent { public EvtOnScriptLoad ( File scriptFile ) { super ( new ScriptAccessor ( new TypeFile ( scriptFile ), \"[script] file\" )); } } Le constructeur EvtOnScriptLoad peut prendre n'importe quels arguments en param\u00e8tres. C'est ce constructeur qui sera appel\u00e9 lorsqu'il faudra d\u00e9clencher l'\u00e9v\u00e8nement. Le constructeur super accepte une infinit\u00e9 d'instances du type ScriptAccessor . Pour rappel, les ScriptAccessor sont des objets qui contiennent un \u00e9l\u00e9ment de n'importe quel type , ainsi qu'un pattern RegEx . En utilisant le constructeur de ScriptAccessor , on peut transformer un pattern en RegEx facilement. Ici, l'accesseur reconna\u00eetra les expressions \"file\" et \"script file\", et retournera le TypeFile() nouvellement instanci\u00e9. Il faut maintenant enregistrer l'\u00e9v\u00e8nement. Il suffit pour cela d'ajouter l'annotation @Event \u00e0 la classe cr\u00e9\u00e9e, puis de remplir les param\u00e8tres demand\u00e9s. Les patterns permettront de reconna\u00eetre l'\u00e9v\u00e8nement lors de la lecture de la ligne. Par exemple, le pattern [script] load[ed] reconna\u00eetra les lignes \"load\", \"script load\", \"script loaded\" et \"loaded\". Enfin, le param\u00e8tre accessors permet d'indiquer au syst\u00e8me de compilation quels accesseurs cet \u00e9v\u00e8nement poss\u00e8de. Voici une classe d'\u00e9v\u00e8nement compl\u00e8te : @Event ( name = \"script load\" , description = \"Called when script is loaded\" , examples = \"on script load:\" , patterns = \"[script] load[ed]\" , accessors = \"[script] file:file\" ) public class EvtOnScriptLoad extends ScriptEvent { public EvtOnScriptLoad ( File scriptFile ) { super ( new ScriptAccessor ( new TypeFile ( scriptFile ), \"[script] file\" )); } }","title":"Cr\u00e9er l'\u00e9v\u00e8nement"},{"location":"fonc/Evenements/#declencher-levenement","text":"Une fois que l'\u00e9v\u00e8nement est enregistr\u00e9, il est possible de l'appeler depuis n'importe quel m\u00e9thode ou fonction java. Pour cela, il suffit d'appeler la m\u00e9thode ScriptManager.callEvent(ScriptEvent) . L'argument ScriptEvent sera simplement une instance de votre classe. Par exemple, pour d\u00e9clencher l'\u00e9v\u00e8nement d\u00e9finit par la classe ci-dessus, la fonction serait appel\u00e9e comme suit : ScriptManager . callEvent ( new EvtOnScriptLoad ( script_file )); Dans ce cas, toutes les instances de scripts recevront l'\u00e9v\u00e8nement. Cette m\u00e9thode retournera true si l'\u00e9v\u00e8nement a \u00e9t\u00e9 annul\u00e9 par un script. Tip Pour cibler un script en particulier, il suffit d'appeler la m\u00eame m\u00e9thode de l'instance de ScriptInstance du script. Pour r\u00e9cup\u00e9rer le contexte apr\u00e8s ex\u00e9cution du script, par exemple si on veut savoir la valeur d'un des accesseurs apr\u00e8s ex\u00e9cution, il suffit d'appeler la m\u00e9thode ScriptManager.callEventAndGetContext(ScriptEvent) . Une instance du ScriptContext vous sera alors renvoy\u00e9e.","title":"D\u00e9clencher l'\u00e9v\u00e8nement"},{"location":"fonc/Expressions/","text":"Pour cr\u00e9er une nouvelle expression, commencez par cr\u00e9er une nouvelle classe qui h\u00e9ritera de la classe ScriptExpression . Puis, impl\u00e9mentez les m\u00e9thodes abstraites de la classe m\u00e8re. Jusqu'ici, l'expression nouvellement cr\u00e9\u00e9e n'a aucune utilit\u00e9. Comme pour les types, il faut l'enregistrer, via l'annotation @Expression . Cette annotation est l\u00e9g\u00e8rement plus complexe \u00e0 compl\u00e9ter. Premi\u00e8rement, il faut fournir un nom, une description et des exemples d'usage de l'expression. Ces param\u00e8tres servent uniquement \u00e0 la g\u00e9n\u00e9ration de documentation et \u00e0 une meilleure lecture du code. En effet, plusieurs expressions peuvent \u00eatre reconnues par une m\u00eame classe , le nom doit donc \u00eatre le plus g\u00e9n\u00e9rique possible. La partie la plus importante concerne les patterns . Il faut en fournir un par expression \u00e0 cr\u00e9er, en notant l'ordre dans lequel ils sont ajout\u00e9s. C'est cet ordre qui permet de savoir quel pattern est \u00e0 traiter . Pour rappel, la syntaxe pour les expressions est : pattern:type de retour . Par exemple, le pattern type of {element}:string retournera une cha\u00eene de caract\u00e8re. La m\u00e9thode la plus importante \u00e0 impl\u00e9menter est la m\u00e9thode get(ScriptContext, ScriptType[]) . C'est elle qui permet de retourner un \u00e9l\u00e9ment en particulier. La m\u00e9thode set(ScriptContext, ScriptType, ScriptType[]) permet de mettre \u00e0 jour la valeur de l'expression lorsque l'action set sera appel\u00e9e. Dans les deux cas, la premi\u00e8re \u00e9tape est de savoir quel pattern a \u00e9t\u00e9 reconnu, afin d'adapter notre code. Le plus simple est d'utiliser un switch sur la valeur de retour de la m\u00e9thode getMatchedIndex() : @Override public ScriptType get ( ScriptContext context , ScriptType [] parameters ) { switch ( getMatchedIndex ()){ case 1 : //C'est le premier pattern qui a \u00e9t\u00e9 reconnu. ... case 2 : //C'est le deuxi\u00e8me pattern qui a \u00e9t\u00e9 reconnu. ... etc . } } Pour obtenir les r\u00e9f\u00e9rences aux param\u00e8tres renseign\u00e9s dans le pattern, on utilise l'argument parameters , qui est une liste contenant les \u00e9l\u00e9ments, dans l'ordre, renseign\u00e9s dans le pattern. Par exemple, dans le pattern type of {element}:string , parameters[0] retournera l'\u00e9l\u00e9ment pass\u00e9 \u00e0 l'expression dans le script ( les listes en java commencent \u00e0 l'indice 0 ). La deuxi\u00e8me m\u00e9thode \u00e0 impl\u00e9menter pour les expressions est la m\u00e9thode set(ScriptContext, ScriptType, ScriptType[]) . Elle permet de mettre \u00e0 jour une valeur lors du passage de l'expression dans l'action set . De la m\u00eame mani\u00e8re, r\u00e9cup\u00e8re le pattern reconnu, puis en fonction de ce dernier on effectue les changements sur les variables pass\u00e9es en param\u00e8tres. Si l'expression ou un pattern en particulier ne peut pas \u00eatre modifi\u00e9, il faut retourner la valeur false , sinon, une fois le changement effectu\u00e9, il faut retourner true . Dans le cas o\u00f9 la valeur retourn\u00e9e est false , une erreur est lev\u00e9e car l'expression n'est pas cens\u00e9e \u00eatre modifi\u00e9e par l'action set . Par exemple, voici une classe ScriptExpression compl\u00e8te : @Expression ( name = \"Types\" , //On d\u00e9finit un nom g\u00e9n\u00e9ral pour la classe. description = \"Manipulate the type of a variable\" , //On d\u00e9crit ce \u00e0 quoi l'expression peut servir. examples = \"type of \\\"test\\\"\" , //On donne un ou plusieurs exemples. patterns = { \"type of {element}:string\" , //On d\u00e9finit le pattern n\u00b00 qui retournera le type du premier param\u00e8tre. \"{element} parsed as {string}:element\" //On d\u00e9finit le pattern n\u00b01 qui retourne un element qui sera le premier param\u00e8tre pars\u00e9 selon le type fourni en deuxi\u00e8me param\u00e8tre.sam }) public class ExprTypeOf extends ScriptExpression { @Override public ScriptType get ( ScriptContext context , ScriptType [] parameters ) { switch ( getMatchedIndex ()){ //On regarde quel pattern a \u00e9t\u00e9 reconnu. case 0 : //Si c'est le premier, on retourne le nom du type du premier param\u00e8tre. return new TypeString ( ScriptType . getTypeName ( parameters [ 0 ] . getClass ())); case 1 : //Si c'est le deuxi\u00e8me pattern, ScriptType parameter_element = parameters [ 0 ] ; //On r\u00e9cup\u00e8re le premier param\u00e8tre. TypeString parameter_string = ( TypeString ) parameters [ 1 ] ; //On r\u00e9cup\u00e8re le second param\u00e8tre. return ( ScriptType ) parameter_element . parse ( parameter_string . getObject ()); //On retourne le premier param\u00e8tre pars\u00e9 selon le deuxi\u00e8me param\u00e8tre. } return null ; //Sinon, on retourne null; } @Override public boolean set ( ScriptContext context , ScriptType to , ScriptType [] parameters ) throws ScriptException . ScriptUndefinedReferenceException { return false ; //Aucun de nos patterns ne peut modifier une valeur d'un param\u00e8tre, on retourne donc false dans tous les cas. } }","title":"Ajouter une expression"},{"location":"fonc/Patterns/","text":"Les patterns compil\u00e9s forment une passerelle entre le langage courant et les expressions r\u00e9guli\u00e8res , bien plus complexes. Ils sont utilis\u00e9s pour reconna\u00eetre une partie du texte qui est en train d'\u00eatre lu, dans les expressions, actions ou fonctions. L'objectif d'un pattern est de reconna\u00eetre du texte. La forme du pattern permet de d\u00e9finir quelles suites de caract\u00e8res on veut pouvoir reconna\u00eetre. \u2022 Une cha\u00eene vierge sera obligatoire. Par exemple, le pattern cancel event ne reconna\u00eetra que la cha\u00eene cancel event . \u2022 Une cha\u00eene entre crochets [] sera optionnelle. Par exemple, le pattern [script] file reconna\u00eetra les cha\u00eenes de caract\u00e8re suivantes : file script file \u2022 Deux cha\u00eenes entre parenth\u00e8ses () s\u00e9par\u00e9es par une barre verticale | seront optionnelles, mais au moins l'une d'entre elle sera obligatoire. Par exemple, le pattern random (numbers|integers) reconna\u00eetra les cha\u00eenes de caract\u00e8res suivantes : random numbers random integers Tip Plusieurs cha\u00eenes peuvent \u00eatre ajout\u00e9es \u00e0 la suite en ajoutant une barre verticale | \u00e0 chaque nouvelle cha\u00eene. Info Il est possible de combiner les patterns pour reconna\u00eetre des phrases plus complexes. Il est possible d'utiliser des crochets dans les parenth\u00e8ses, et r\u00e9ciproquement. Il est \u00e9galement possible de param\u00e9trer des arguments pour les expressions ou les actions. Il suffit de mettre entre accolades {} le nom du type attendu. Pour indiquer qu'il peut y avoir n'importe quel type, il suffit d'utiliser le type {element} , puisque tous les types h\u00e9ritent du type element . Tip Pour les expressions, fonctions et actions, renseigner un type sp\u00e9cifique n'est g\u00e9n\u00e9ralement pas utile lors du runtime, puisque les variables ne sont pas typ\u00e9es. Cependant, cela permet une meilleure compr\u00e9hension du pattern et des variables attendues (car une erreur sera lanc\u00e9e si un cast vers ce type est impossible) par l'action ou l'expression, ainsi qu'une meilleure g\u00e9n\u00e9ration de la documentation . Par exemple, le pattern random element of {array} indique qu'un tableau est attendu apr\u00e8s une cha\u00eene de caract\u00e8re \u00e9gale \u00e0 random element of . Si l'expression pass\u00e9e n'est pas un tableau, une erreur sera lev\u00e9e lors du runtime. Enfin pour les expressions et les fonctions, il est possible d'indiquer leur type de retour. Il suffit pour cela de rajouter le nom du type \u00e0 la fin de la cha\u00eene, apr\u00e8s deux points : . Ainsi, le pattern size of {array}:number indique qu'un nombre est renvoy\u00e9 par ce pattern de l'expression ou de la fonction.","title":"Les patterns"},{"location":"fonc/ScriptClock/","text":"Le ScriptClock est \u00e9galement tr\u00e8s important dans la manipulation de l'ex\u00e9cution des scripts. C'est en quelque sorte le chef d'orchestre de l'ex\u00e9cution d'un script. Il permet d'arr\u00eater, de reprendre ou de d\u00e9layer la cha\u00eene d'ex\u00e9cution des actions d'un bloc. En effet, un bloc d'action est parcouru de proche en proche, similairement au parcours d'un arbre avec une branche principale, pouvant momentan\u00e9ment (lors du passage dans les boucles) revenir sur lui m\u00eame. Cette structure non r\u00e9cursive permet une efficacit\u00e9 accrue et une meilleure gestion de la m\u00e9moire lors de la lecture du script. L'action ActWait est un bon exemple d'utilisation de l'objet ScriptClock .","title":"ScriptClock"},{"location":"fonc/ScriptContext/","text":"L'objet ScriptContext permet de modifier ou de r\u00e9cup\u00e9rer des donn\u00e9es relatives au contexte dans lequel une expression, une action ou une fonction est appel\u00e9e. Les champs d'une instance d'un ScriptContext peuvent \u00eatre utiles lors d'une utilisation pouss\u00e9e de Sqript. Le champ returnValue est le type de retour une fois le bloc termin\u00e9 ou interrompu. C'est notamment cette valeur qui permet de d\u00e9terminer si un \u00e9v\u00e8nement a \u00e9t\u00e9 annul\u00e9, ou de conna\u00eetre la valeur de retour d'une fonction interne \u00e0 un script. Le champ variables qui est une List de ScriptAccessor , qui permettent d'acc\u00e9der \u00e0 un ScriptType en fonction d'un pattern RegEx . Elle contient toutes les variables appartenant au bloc. Une instance du ScriptContext est toujours pass\u00e9e aux m\u00e9thodes d'ex\u00e9cution des expressions et des actions, ce qui permet entre autres d'acc\u00e9der aux accesseurs d'un \u00e9v\u00e8nement directement depuis le code Java.","title":"Le ScriptContext"},{"location":"fonc/Type/","text":"Les types sont la base du fonctionnement des scripts. Ce sont simplement des classes \"encapsul\u00e9es\" dans une classe particuli\u00e8re : le ScriptType . C'est le fait d'h\u00e9riter cette classe et d'impl\u00e9menter certaines interfaces qui permet de d\u00e9finir un comportement \u00e0 l'objet que l'ont veut int\u00e9grer \u00e0 Sqript. Types Pour cr\u00e9er un nouveau type, commencer par cr\u00e9er une nouvelle classe h\u00e9ritant de la classe ScriptType<T> avec T la classe de l'objet \u00e0 impl\u00e9menter. Par exemple, il est possible de d\u00e9finir un ScriptType<EntityPlayer> , qui d\u00e9finira comment se comporte les instances de la classe EntityPlayer dans un script. Ensuite, impl\u00e9menter les m\u00e9thodes abstraites de la classe m\u00e8re. La m\u00e9thode la plus importante de la classe est le constructeur, qui va permettre d'encapsuler l'instance de la classe que vous souhaitez int\u00e9grer dans un ScriptType . Un appel au constructeur super suffit pour encapsuler la variable. Par exemple pour la classe EntityPlayer : public class TypePlayer extends ScriptType < EntityPlayer > { public TypePlayer ( EntityPlayer player ){ super ( player ); } @Override public ScriptElement <?> parse ( String typeName ) { return null ; } } Compl\u00e9ter la m\u00e9thode parse() n'est pas obligatoire, mais peut \u00eatre tr\u00e8s utile dans certaines situations. Retourner null d\u00e9sactivera la capacit\u00e9 du type \u00e0 \u00eatre pars\u00e9 . Jusqu'alors, le type n'est pas encore utilisable : il faut l'enregistrer. Pour ce faire, il suffit d'annoter la classe avec l'annotation @Type : @Type ( name = \"player\" , parsableAs = {}) public class TypePlayer extends ScriptType < EntityPlayer > { public TypePlayer ( EntityPlayer player ){ super ( player ); } @Override public ScriptElement <?> parse ( String typeName ) { return null ; } } Tip Il est possible de surcharger la m\u00e9thode toString() pour d\u00e9finir le comportement de l'objet lorsqu'il sera converti en TypeString . Pour tous les autres types, il faudra passer par la m\u00e9thode parse() . Tip Il peut \u00eatre int\u00e9ressant de faire votre propre impl\u00e9mentation de la fonction hashCode() pour assurer un bonne gestion de votre type dans les tableaux ou les dictionnaires. Vous aurez acc\u00e8s \u00e0 l'objet encapsul\u00e9 en gr\u00e2ce au param\u00e8tre object de l'instance de votre classe. Il est possible de complexifier le comportement du type en impl\u00e9mentant certaines interfaces : ISerialisable permet de d\u00e9finir le type comme \u00e9tant enregistrable. Toute variable globale ayant un type n'impl\u00e9mentant pas cette interface ne pourra \u00eatre enregistr\u00e9e. Cette interface comprend deux m\u00e9thodes, read() et write() , qui agissent sur des tags NBT . Elles sont respectivement appel\u00e9es d'abord au lancement de Sqript pour charger la valeur de la variable, puis \u00e0 la fermeture pour l'enregistrer. Types primitifs Les primitifs sont des types pouvant \u00eatre instanci\u00e9s sans passer par une expression. Le principe de cr\u00e9ation est le m\u00eame que celui des types normaux, la classe \u00e0 h\u00e9riter devient PrimitiveType<T> , et l'annotation devient @Primitive . Un nouveau param\u00e8tre accompagne cette annotation, il s'agit du pattern de la primitive. Attention, ce pattern doit \u00eatre une expression r\u00e9guli\u00e8re . De la m\u00eame mani\u00e8re que pour les types normaux, il est n\u00e9cessaire d'impl\u00e9menter les m\u00e9thodes abstraites de la classe m\u00e8re. La m\u00e9thode fromString() est la m\u00e9thode la plus importante des types primitifs, ainsi que leur constructeur, acceptant un argument du type encapsul\u00e9. De plus, une type primitif doit avoir un constructeur acceptant une unique cha\u00eene de caract\u00e8re qui sera \u00e0 parser . Voici par exemple le contenu du type primitif TypeString : @Primitive ( name = \"string\" , parsableAs = {}, pattern = \"(?:\\\"((?:[^\\\"\\\\\\\\\\\\\\\\]|\\\\\\\\.)*)\\\")\" ; ) public class TypeString extends PrimitiveType < String > implements IOperable { @Nullable @Override public ScriptElement parse ( String typeName ) { return null ; } public TypeString ( String parameter ){ super ( parameter ); } } Le pattern est une RegEx , qui sont bien plus complexes que les *patterns, mais aussi plus flexibles et plus puissantes. Il est indispensable de les ma\u00eetriser afin de cr\u00e9er des types primitifs. Le param\u00e8tre match pass\u00e9 au constructeur est le premier groupe captur\u00e9 par l'expression r\u00e9guli\u00e8re du pattern. Ici, le groupe capture automatiquement tout ce qui se trouve entre les guillemets, aucune manipulation n'est donc n\u00e9cessaire. Cependant, dans le cas des nombres par exemple, il faut utiliser les m\u00e9thodes ad\u00e9quates. Les m\u00eames interfaces que pour les types normaux peuvent s'appliquer aux primitives. Tip Par convention, on appellera \u00e9galement les classes de types primitives \" Type\\ \", pour permettre une meilleure \u00e9criture et lisibilit\u00e9 du code. Op\u00e9rations & op\u00e9rateurs \u00c9tablir une op\u00e9ration entre deux \u00e9l\u00e9ments n'est pas une t\u00e2che difficile, mais n\u00e9cessite quelques bases en ce qui concerne les termes que l'on retrouve dans une expression math\u00e9matique. On appellera op\u00e9rateur tous les symboles permettant de mettre en relation les op\u00e9randes . Les op\u00e9randes seront d'autres \u00e9l\u00e9ments provenant d'autres expressions. La notion d'op\u00e9rateur dans Sqript est tr\u00e8s abstraite, et il faut prendre en charge chaque cas d'op\u00e9rateur pour d\u00e9finir correctement un type que l'ont d\u00e9sire pouvoir comparer, composer, etc. L'\u00e9galit\u00e9 = notamment est un op\u00e9rateur au m\u00eame titre que l'addition + , mais doit retourner un TypeBoolean vrai ou faux. Enregistrer un nouvel op\u00e9rateur Il est possible d'enregistrer des op\u00e9rateurs personnalis\u00e9s lors du chargement de votre addon. Il suffira d'appeler la m\u00e9thode registerOperator(ScriptOperator) de la classe ScriptManager pour enregistrer un nouvel op\u00e9rateur. Un op\u00e9rateur s'instancie via le constructeur de la classe ScriptOperator , et n\u00e9cessite au plus 7 arguments que sont : Le symbole de l'op\u00e9rateur. Par exemple, \"+\". La priorit\u00e9 de l'op\u00e9rateur. (cf. Op\u00e9rateurs pr\u00e9-existants ) L'associativit\u00e9 de l'op\u00e9ration. Elle peut \u00eatre de gauche \u00e0 droite ( Associativity.LEFT_TO_RIGHT ), de droite \u00e0 gauche ( Associativity.RIGHT_TO_LEFT ) ou nulle ( Associativity.NONE ) ( ? ). La binarit\u00e9 de l'op\u00e9rateur. Un op\u00e9rateur binaire compose 2 \u00e9l\u00e9ments pour en donner un nouveau, tandis qu'un op\u00e9rateur unaire transforme 1 seul \u00e9l\u00e9ment en un nouveau. Configurer \u00e0 false si l'op\u00e9rateur est binaire, true s'il est unaire. La mani\u00e8re dont l'op\u00e9rateur doit \u00eatre lu. Si la valeur est true , l'op\u00e9rateur ne sera reconnu que s'il est s\u00e9par\u00e9 par au moins un espace de l'op\u00e9rande de gauche et de l'op\u00e9rande de droite. true si l'op\u00e9rateur est post-fix\u00e9. Ce qui est le cas du symbole factorielle ! par exemple, cela signifie qu'il s'\u00e9crit en notation infix\u00e9e (la notation naturelle) apr\u00e8s le ou les op\u00e9rande(s) sur lesquels il s'applique. Op\u00e9rateurs pr\u00e9-existants Symbole Description Priorit\u00e9 Associativit\u00e9 Binarit\u00e9 Mot Position + \"+\" Unaire 14 Droite \u00e0 gauche Unaire Non Pr\u00e9-fix\u00e9e - \"-\" Unaire 14 Droite \u00e0 gauche Unaire Non Pr\u00e9-fix\u00e9e ! Factorielle 14 Droite \u00e0 gauche Unaire Non Post-fix\u00e9e * Multiplication 12 Gauche \u00e0 droite Binaire Non Infix\u00e9e / Division 12 Gauche \u00e0 droite Binaire Non Infix\u00e9e + Addition 11 Gauche \u00e0 droite Binaire Non Infix\u00e9e - Soustraction 11 Gauche \u00e0 droite Binaire Non Infix\u00e9e >= Sup\u00e9rieur ou \u00e9gal \u00e0 9 Gauche \u00e0 droite Binaire Non Infix\u00e9e <= Inf\u00e9rieur ou \u00e9gal \u00e0 9 Gauche \u00e0 droite Binaire Non Infix\u00e9e > Sup\u00e9rieur \u00e0 9 Gauche \u00e0 droite Binaire Non Infix\u00e9e < Inf\u00e9rieur \u00e0 9 Gauche \u00e0 droite Binaire Non Infix\u00e9e = \u00c9galit\u00e9 8 Gauche \u00e0 droite Binaire Non Infix\u00e9e not N\u00e9gation logique 5 Gauche \u00e0 droite Unaire Oui Pr\u00e9-fix\u00e9e and \"Et\" logique 4 Gauche \u00e0 droite Binaire Oui Infix\u00e9e or \"Ou\" logique 3 Gauche \u00e0 droite Binaire Oui Post-fix\u00e9e D\u00e9finir une op\u00e9ration pour un type Les op\u00e9rations entre les types sont toutes enregistr\u00e9es dans la m\u00eame Map , ce qui permet de les modifier si besoin. Pour enregistrer une op\u00e9ration, il suffit d'appeler la m\u00e9thode ScriptManager.registerBinaryOperation() (dans un bloc static de la classe du type par exemple) pour les op\u00e9rations binaires et ScriptManager.registerUnaryOperation() pour les op\u00e9rations unaires . Il faut ensuite renseigner l'op\u00e9rateur, le type de la classe \u00e0 gauche , et le type de la classe \u00e0 droite si l'op\u00e9ration est binaire. Par exemple, pour d\u00e9finir une addition entre deux nombres : static { ScriptManager . registerBinaryOperation ( ScriptOperator . ADD , TypeNumber . class , TypeNumber . class , ( a , b ) -> new TypeNumber ( (( TypeNumber ) a ). object + (( TypeNumber ) b ). object ) ); } Vous pouvez utiliser le type ScriptType.class pour indiquer que vous pouvez utiliser l'op\u00e9ration avec n'importe quel type. Cependant, cette d\u00e9finition sera consid\u00e9r\u00e9e en derni\u00e8re si d'autres d\u00e9finitions avec le m\u00eame op\u00e9rateur sont d\u00e9j\u00e0 enregistr\u00e9es. C'est notamment le cas avec la concat\u00e9nation de cha\u00eenes de caract\u00e8res : static { ScriptManager . registerBinaryOperation ( ScriptOperator . ADD , TypeString . class , ScriptType . class , ( a , b ) -> new TypeString ( (( TypeString ) a ). object + b . toString ()) ); } Et voil\u00e0, l'op\u00e9ration est enregistr\u00e9e. Le compilateur d'expressions math\u00e9matiques de Sqript se chargera d'appliquer les op\u00e9rations sur votre type en utilisant l'op\u00e9ration que vous avez d\u00e9fini.","title":"Ajouter un type"},{"location":"fonc/Type/#types","text":"Pour cr\u00e9er un nouveau type, commencer par cr\u00e9er une nouvelle classe h\u00e9ritant de la classe ScriptType<T> avec T la classe de l'objet \u00e0 impl\u00e9menter. Par exemple, il est possible de d\u00e9finir un ScriptType<EntityPlayer> , qui d\u00e9finira comment se comporte les instances de la classe EntityPlayer dans un script. Ensuite, impl\u00e9menter les m\u00e9thodes abstraites de la classe m\u00e8re. La m\u00e9thode la plus importante de la classe est le constructeur, qui va permettre d'encapsuler l'instance de la classe que vous souhaitez int\u00e9grer dans un ScriptType . Un appel au constructeur super suffit pour encapsuler la variable. Par exemple pour la classe EntityPlayer : public class TypePlayer extends ScriptType < EntityPlayer > { public TypePlayer ( EntityPlayer player ){ super ( player ); } @Override public ScriptElement <?> parse ( String typeName ) { return null ; } } Compl\u00e9ter la m\u00e9thode parse() n'est pas obligatoire, mais peut \u00eatre tr\u00e8s utile dans certaines situations. Retourner null d\u00e9sactivera la capacit\u00e9 du type \u00e0 \u00eatre pars\u00e9 . Jusqu'alors, le type n'est pas encore utilisable : il faut l'enregistrer. Pour ce faire, il suffit d'annoter la classe avec l'annotation @Type : @Type ( name = \"player\" , parsableAs = {}) public class TypePlayer extends ScriptType < EntityPlayer > { public TypePlayer ( EntityPlayer player ){ super ( player ); } @Override public ScriptElement <?> parse ( String typeName ) { return null ; } } Tip Il est possible de surcharger la m\u00e9thode toString() pour d\u00e9finir le comportement de l'objet lorsqu'il sera converti en TypeString . Pour tous les autres types, il faudra passer par la m\u00e9thode parse() . Tip Il peut \u00eatre int\u00e9ressant de faire votre propre impl\u00e9mentation de la fonction hashCode() pour assurer un bonne gestion de votre type dans les tableaux ou les dictionnaires. Vous aurez acc\u00e8s \u00e0 l'objet encapsul\u00e9 en gr\u00e2ce au param\u00e8tre object de l'instance de votre classe. Il est possible de complexifier le comportement du type en impl\u00e9mentant certaines interfaces : ISerialisable permet de d\u00e9finir le type comme \u00e9tant enregistrable. Toute variable globale ayant un type n'impl\u00e9mentant pas cette interface ne pourra \u00eatre enregistr\u00e9e. Cette interface comprend deux m\u00e9thodes, read() et write() , qui agissent sur des tags NBT . Elles sont respectivement appel\u00e9es d'abord au lancement de Sqript pour charger la valeur de la variable, puis \u00e0 la fermeture pour l'enregistrer.","title":"Types"},{"location":"fonc/Type/#types-primitifs","text":"Les primitifs sont des types pouvant \u00eatre instanci\u00e9s sans passer par une expression. Le principe de cr\u00e9ation est le m\u00eame que celui des types normaux, la classe \u00e0 h\u00e9riter devient PrimitiveType<T> , et l'annotation devient @Primitive . Un nouveau param\u00e8tre accompagne cette annotation, il s'agit du pattern de la primitive. Attention, ce pattern doit \u00eatre une expression r\u00e9guli\u00e8re . De la m\u00eame mani\u00e8re que pour les types normaux, il est n\u00e9cessaire d'impl\u00e9menter les m\u00e9thodes abstraites de la classe m\u00e8re. La m\u00e9thode fromString() est la m\u00e9thode la plus importante des types primitifs, ainsi que leur constructeur, acceptant un argument du type encapsul\u00e9. De plus, une type primitif doit avoir un constructeur acceptant une unique cha\u00eene de caract\u00e8re qui sera \u00e0 parser . Voici par exemple le contenu du type primitif TypeString : @Primitive ( name = \"string\" , parsableAs = {}, pattern = \"(?:\\\"((?:[^\\\"\\\\\\\\\\\\\\\\]|\\\\\\\\.)*)\\\")\" ; ) public class TypeString extends PrimitiveType < String > implements IOperable { @Nullable @Override public ScriptElement parse ( String typeName ) { return null ; } public TypeString ( String parameter ){ super ( parameter ); } } Le pattern est une RegEx , qui sont bien plus complexes que les *patterns, mais aussi plus flexibles et plus puissantes. Il est indispensable de les ma\u00eetriser afin de cr\u00e9er des types primitifs. Le param\u00e8tre match pass\u00e9 au constructeur est le premier groupe captur\u00e9 par l'expression r\u00e9guli\u00e8re du pattern. Ici, le groupe capture automatiquement tout ce qui se trouve entre les guillemets, aucune manipulation n'est donc n\u00e9cessaire. Cependant, dans le cas des nombres par exemple, il faut utiliser les m\u00e9thodes ad\u00e9quates. Les m\u00eames interfaces que pour les types normaux peuvent s'appliquer aux primitives. Tip Par convention, on appellera \u00e9galement les classes de types primitives \" Type\\ \", pour permettre une meilleure \u00e9criture et lisibilit\u00e9 du code.","title":"Types primitifs"},{"location":"fonc/Type/#operations-operateurs","text":"\u00c9tablir une op\u00e9ration entre deux \u00e9l\u00e9ments n'est pas une t\u00e2che difficile, mais n\u00e9cessite quelques bases en ce qui concerne les termes que l'on retrouve dans une expression math\u00e9matique. On appellera op\u00e9rateur tous les symboles permettant de mettre en relation les op\u00e9randes . Les op\u00e9randes seront d'autres \u00e9l\u00e9ments provenant d'autres expressions. La notion d'op\u00e9rateur dans Sqript est tr\u00e8s abstraite, et il faut prendre en charge chaque cas d'op\u00e9rateur pour d\u00e9finir correctement un type que l'ont d\u00e9sire pouvoir comparer, composer, etc. L'\u00e9galit\u00e9 = notamment est un op\u00e9rateur au m\u00eame titre que l'addition + , mais doit retourner un TypeBoolean vrai ou faux.","title":"Op\u00e9rations &amp; op\u00e9rateurs"},{"location":"fonc/Type/#enregistrer-un-nouvel-operateur","text":"Il est possible d'enregistrer des op\u00e9rateurs personnalis\u00e9s lors du chargement de votre addon. Il suffira d'appeler la m\u00e9thode registerOperator(ScriptOperator) de la classe ScriptManager pour enregistrer un nouvel op\u00e9rateur. Un op\u00e9rateur s'instancie via le constructeur de la classe ScriptOperator , et n\u00e9cessite au plus 7 arguments que sont : Le symbole de l'op\u00e9rateur. Par exemple, \"+\". La priorit\u00e9 de l'op\u00e9rateur. (cf. Op\u00e9rateurs pr\u00e9-existants ) L'associativit\u00e9 de l'op\u00e9ration. Elle peut \u00eatre de gauche \u00e0 droite ( Associativity.LEFT_TO_RIGHT ), de droite \u00e0 gauche ( Associativity.RIGHT_TO_LEFT ) ou nulle ( Associativity.NONE ) ( ? ). La binarit\u00e9 de l'op\u00e9rateur. Un op\u00e9rateur binaire compose 2 \u00e9l\u00e9ments pour en donner un nouveau, tandis qu'un op\u00e9rateur unaire transforme 1 seul \u00e9l\u00e9ment en un nouveau. Configurer \u00e0 false si l'op\u00e9rateur est binaire, true s'il est unaire. La mani\u00e8re dont l'op\u00e9rateur doit \u00eatre lu. Si la valeur est true , l'op\u00e9rateur ne sera reconnu que s'il est s\u00e9par\u00e9 par au moins un espace de l'op\u00e9rande de gauche et de l'op\u00e9rande de droite. true si l'op\u00e9rateur est post-fix\u00e9. Ce qui est le cas du symbole factorielle ! par exemple, cela signifie qu'il s'\u00e9crit en notation infix\u00e9e (la notation naturelle) apr\u00e8s le ou les op\u00e9rande(s) sur lesquels il s'applique.","title":"Enregistrer un nouvel op\u00e9rateur"},{"location":"fonc/Type/#operateurs-pre-existants","text":"Symbole Description Priorit\u00e9 Associativit\u00e9 Binarit\u00e9 Mot Position + \"+\" Unaire 14 Droite \u00e0 gauche Unaire Non Pr\u00e9-fix\u00e9e - \"-\" Unaire 14 Droite \u00e0 gauche Unaire Non Pr\u00e9-fix\u00e9e ! Factorielle 14 Droite \u00e0 gauche Unaire Non Post-fix\u00e9e * Multiplication 12 Gauche \u00e0 droite Binaire Non Infix\u00e9e / Division 12 Gauche \u00e0 droite Binaire Non Infix\u00e9e + Addition 11 Gauche \u00e0 droite Binaire Non Infix\u00e9e - Soustraction 11 Gauche \u00e0 droite Binaire Non Infix\u00e9e >= Sup\u00e9rieur ou \u00e9gal \u00e0 9 Gauche \u00e0 droite Binaire Non Infix\u00e9e <= Inf\u00e9rieur ou \u00e9gal \u00e0 9 Gauche \u00e0 droite Binaire Non Infix\u00e9e > Sup\u00e9rieur \u00e0 9 Gauche \u00e0 droite Binaire Non Infix\u00e9e < Inf\u00e9rieur \u00e0 9 Gauche \u00e0 droite Binaire Non Infix\u00e9e = \u00c9galit\u00e9 8 Gauche \u00e0 droite Binaire Non Infix\u00e9e not N\u00e9gation logique 5 Gauche \u00e0 droite Unaire Oui Pr\u00e9-fix\u00e9e and \"Et\" logique 4 Gauche \u00e0 droite Binaire Oui Infix\u00e9e or \"Ou\" logique 3 Gauche \u00e0 droite Binaire Oui Post-fix\u00e9e","title":"Op\u00e9rateurs pr\u00e9-existants"},{"location":"fonc/Type/#definir-une-operation-pour-un-type","text":"Les op\u00e9rations entre les types sont toutes enregistr\u00e9es dans la m\u00eame Map , ce qui permet de les modifier si besoin. Pour enregistrer une op\u00e9ration, il suffit d'appeler la m\u00e9thode ScriptManager.registerBinaryOperation() (dans un bloc static de la classe du type par exemple) pour les op\u00e9rations binaires et ScriptManager.registerUnaryOperation() pour les op\u00e9rations unaires . Il faut ensuite renseigner l'op\u00e9rateur, le type de la classe \u00e0 gauche , et le type de la classe \u00e0 droite si l'op\u00e9ration est binaire. Par exemple, pour d\u00e9finir une addition entre deux nombres : static { ScriptManager . registerBinaryOperation ( ScriptOperator . ADD , TypeNumber . class , TypeNumber . class , ( a , b ) -> new TypeNumber ( (( TypeNumber ) a ). object + (( TypeNumber ) b ). object ) ); } Vous pouvez utiliser le type ScriptType.class pour indiquer que vous pouvez utiliser l'op\u00e9ration avec n'importe quel type. Cependant, cette d\u00e9finition sera consid\u00e9r\u00e9e en derni\u00e8re si d'autres d\u00e9finitions avec le m\u00eame op\u00e9rateur sont d\u00e9j\u00e0 enregistr\u00e9es. C'est notamment le cas avec la concat\u00e9nation de cha\u00eenes de caract\u00e8res : static { ScriptManager . registerBinaryOperation ( ScriptOperator . ADD , TypeString . class , ScriptType . class , ( a , b ) -> new TypeString ( (( TypeString ) a ). object + b . toString ()) ); } Et voil\u00e0, l'op\u00e9ration est enregistr\u00e9e. Le compilateur d'expressions math\u00e9matiques de Sqript se chargera d'appliquer les op\u00e9rations sur votre type en utilisant l'op\u00e9ration que vous avez d\u00e9fini.","title":"D\u00e9finir une op\u00e9ration pour un type"}]}